CCS PCH C Compiler, Version 5.025, 40073               25-Thg11-17 22:26

               Filename:   D:\du lieu\BSD\BSD datasheet\sensiriion spd800\sensirion_pic_18f2480_can transfer\REPORT SHT BME280 TRANSFER\main.lst

               ROM used:   6256 bytes (38%)
                           Largest free fragment is 10124
               RAM used:   59 (8%) at main() level
                           120 (16%) worst case
               Stack used: 4 locations (3 in main + 1 for interrupts)
               Stack size: 31

*
0000:  GOTO   156A
*
0008:  MOVWF  04
000A:  MOVFF  FD8,05
000E:  MOVFF  FE0,06
0012:  MOVLB  0
0014:  MOVFF  FE9,0C
0018:  MOVFF  FEA,07
001C:  MOVFF  FE1,08
0020:  MOVFF  FE2,09
0024:  MOVFF  FD9,0A
0028:  MOVFF  FDA,0B
002C:  MOVFF  FF3,12
0030:  MOVFF  FF4,13
0034:  MOVFF  FFA,14
0038:  MOVFF  FF5,15
003C:  MOVFF  FF6,16
0040:  MOVFF  FF7,17
0044:  MOVFF  00,0E
0048:  MOVFF  01,0F
004C:  MOVFF  02,10
0050:  MOVFF  03,11
0054:  BTFSS  F9D.1
0056:  GOTO   0060
005A:  BTFSC  F9E.1
005C:  GOTO   052A
0060:  MOVFF  0E,00
0064:  MOVFF  0F,01
0068:  MOVFF  10,02
006C:  MOVFF  11,03
0070:  MOVFF  0C,FE9
0074:  MOVFF  07,FEA
0078:  BSF    07.7
007A:  MOVFF  08,FE1
007E:  MOVFF  09,FE2
0082:  MOVFF  0A,FD9
0086:  MOVFF  0B,FDA
008A:  MOVFF  12,FF3
008E:  MOVFF  13,FF4
0092:  MOVFF  14,FFA
0096:  MOVFF  15,FF5
009A:  MOVFF  16,FF6
009E:  MOVFF  17,FF7
00A2:  MOVF   04,W
00A4:  MOVFF  06,FE0
00A8:  MOVFF  05,FD8
00AC:  RETFIE 0
....................  
.................... #include <18F2480.h> 
.................... //////////// Standard Header file for the PIC18F2480 device //////////////// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996, 2013 Custom Computer Services          //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... #device PIC18F2480 
00AE:  DATA 0D,0A
00B0:  DATA 20,63
00B2:  DATA 6F,6E
00B4:  DATA 74,69
00B6:  DATA 6E,75
00B8:  DATA 6F,75
00BA:  DATA 73,20
00BC:  DATA 6D,65
00BE:  DATA 61,73
00C0:  DATA 75,72
00C2:  DATA 65,20
00C4:  DATA 77,72
00C6:  DATA 69,74
00C8:  DATA 65,28
00CA:  DATA 30,78
00CC:  DATA 34,41
00CE:  DATA 29,3A
00D0:  DATA 20,25
00D2:  DATA 75,00
00D4:  DATA 0D,0A
00D6:  DATA 20,63
00D8:  DATA 6F,6E
00DA:  DATA 74,69
00DC:  DATA 6E,75
00DE:  DATA 6F,75
00E0:  DATA 73,20
00E2:  DATA 6D,65
00E4:  DATA 61,73
00E6:  DATA 75,72
00E8:  DATA 65,20
00EA:  DATA 77,72
00EC:  DATA 69,74
00EE:  DATA 65,28
00F0:  DATA 30,78
00F2:  DATA 33,36
00F4:  DATA 29,3A
00F6:  DATA 20,25
00F8:  DATA 75,00
00FA:  DATA 0D,0A
00FC:  DATA 20,63
00FE:  DATA 6F,6E
0100:  DATA 74,69
0102:  DATA 6E,75
0104:  DATA 6F,75
0106:  DATA 73,20
0108:  DATA 6D,65
010A:  DATA 61,73
010C:  DATA 75,72
010E:  DATA 65,20
0110:  DATA 77,72
0112:  DATA 69,74
0114:  DATA 65,28
0116:  DATA 30,78
0118:  DATA 31,35
011A:  DATA 29,3A
011C:  DATA 20,25
011E:  DATA 75,00
0120:  DATA 0D,0A
0122:  DATA 20,73
0124:  DATA 74,6F
0126:  DATA 70,20
0128:  DATA 77,72
012A:  DATA 69,74
012C:  DATA 65,28
012E:  DATA 30,78
0130:  DATA 34,41
0132:  DATA 29,3A
0134:  DATA 20,25
0136:  DATA 75,00
0138:  DATA 0D,0A
013A:  DATA 20,73
013C:  DATA 74,6F
013E:  DATA 70,20
0140:  DATA 77,72
0142:  DATA 69,74
0144:  DATA 65,28
0146:  DATA 30,78
0148:  DATA 33,46
014A:  DATA 29,3A
014C:  DATA 20,25
014E:  DATA 75,00
0150:  DATA 0D,0A
0152:  DATA 20,73
0154:  DATA 74,6F
0156:  DATA 70,20
0158:  DATA 77,72
015A:  DATA 69,74
015C:  DATA 65,28
015E:  DATA 30,78
0160:  DATA 46,39
0162:  DATA 29,3A
0164:  DATA 20,25
0166:  DATA 75,00
0168:  DATA 0D,0A
016A:  DATA 20,72
016C:  DATA 65,73
016E:  DATA 65,74
0170:  DATA 20,77
0172:  DATA 72,69
0174:  DATA 74,65
0176:  DATA 28,30
0178:  DATA 78,30
017A:  DATA 30,29
017C:  DATA 3A,20
017E:  DATA 25,75
0180:  DATA 00,00
0182:  DATA 0D,0A
0184:  DATA 20,72
0186:  DATA 65,73
0188:  DATA 65,74
018A:  DATA 20,77
018C:  DATA 72,69
018E:  DATA 74,65
0190:  DATA 28,30
0192:  DATA 78,30
0194:  DATA 36,29
0196:  DATA 3A,20
0198:  DATA 25,75
019A:  DATA 00,00
019C:  DATA 0D,0A
019E:  DATA 53,65
01A0:  DATA 6E,73
01A2:  DATA 69,72
01A4:  DATA 69,6F
01A6:  DATA 6E,20
01A8:  DATA 73,74
01AA:  DATA 61,74
01AC:  DATA 75,73
01AE:  DATA 3A,20
01B0:  DATA 25,75
01B2:  DATA 00,00
01B4:  DATA 0D,0A
01B6:  DATA 53,65
01B8:  DATA 6E,73
01BA:  DATA 69,72
01BC:  DATA 69,6F
01BE:  DATA 6E,20
01C0:  DATA 73,74
01C2:  DATA 61,74
01C4:  DATA 75,73
01C6:  DATA 31,3A
01C8:  DATA 20,25
01CA:  DATA 75,00
01CC:  DATA 0D,0A
01CE:  DATA 53,65
01D0:  DATA 6E,73
01D2:  DATA 69,72
01D4:  DATA 69,6F
01D6:  DATA 6E,20
01D8:  DATA 73,74
01DA:  DATA 61,74
01DC:  DATA 75,73
01DE:  DATA 32,3A
01E0:  DATA 20,25
01E2:  DATA 75,00
01E4:  DATA 0D,0A
01E6:  DATA 53,65
01E8:  DATA 6E,73
01EA:  DATA 69,72
01EC:  DATA 69,6F
01EE:  DATA 6E,20
01F0:  DATA 73,74
01F2:  DATA 61,74
01F4:  DATA 75,73
01F6:  DATA 33,3A
01F8:  DATA 20,25
01FA:  DATA 75,00
01FC:  DATA 0D,0A
01FE:  DATA 53,65
0200:  DATA 6E,73
0202:  DATA 69,72
0204:  DATA 69,6F
0206:  DATA 6E,20
0208:  DATA 73,74
020A:  DATA 61,74
020C:  DATA 75,73
020E:  DATA 34,3A
0210:  DATA 20,25
0212:  DATA 75,00
0214:  DATA 0D,0A
0216:  DATA 53,65
0218:  DATA 6E,73
021A:  DATA 69,72
021C:  DATA 69,6F
021E:  DATA 6E,20
0220:  DATA 73,74
0222:  DATA 61,74
0224:  DATA 75,73
0226:  DATA 35,3A
0228:  DATA 20,25
022A:  DATA 75,00
022C:  DATA 0D,0A
022E:  DATA 53,65
0230:  DATA 6E,73
0232:  DATA 69,72
0234:  DATA 69,6F
0236:  DATA 6E,20
0238:  DATA 49,44
023A:  DATA 20,44
023C:  DATA 41,54
023E:  DATA 41,5B
0240:  DATA 30,5D
0242:  DATA 3A,20
0244:  DATA 25,30
0246:  DATA 32,58
0248:  DATA 00,00
024A:  DATA 0D,0A
024C:  DATA 53,65
024E:  DATA 6E,73
0250:  DATA 69,72
0252:  DATA 69,6F
0254:  DATA 6E,20
0256:  DATA 49,44
0258:  DATA 20,44
025A:  DATA 41,54
025C:  DATA 41,5B
025E:  DATA 31,5D
0260:  DATA 3A,20
0262:  DATA 25,30
0264:  DATA 32,58
0266:  DATA 00,00
0268:  DATA 0D,0A
026A:  DATA 53,65
026C:  DATA 6E,73
026E:  DATA 69,72
0270:  DATA 69,6F
0272:  DATA 6E,20
0274:  DATA 49,44
0276:  DATA 20,44
0278:  DATA 41,54
027A:  DATA 41,5B
027C:  DATA 32,5D
027E:  DATA 3A,20
0280:  DATA 25,30
0282:  DATA 32,58
0284:  DATA 00,00
0286:  DATA 0D,0A
0288:  DATA 53,65
028A:  DATA 6E,73
028C:  DATA 69,72
028E:  DATA 69,6F
0290:  DATA 6E,20
0292:  DATA 49,44
0294:  DATA 20,44
0296:  DATA 41,54
0298:  DATA 41,5B
029A:  DATA 33,5D
029C:  DATA 3A,20
029E:  DATA 25,30
02A0:  DATA 32,58
02A2:  DATA 00,00
02A4:  DATA 0D,0A
02A6:  DATA 53,65
02A8:  DATA 6E,73
02AA:  DATA 69,72
02AC:  DATA 69,6F
02AE:  DATA 6E,20
02B0:  DATA 49,44
02B2:  DATA 20,44
02B4:  DATA 41,54
02B6:  DATA 41,5B
02B8:  DATA 34,5D
02BA:  DATA 3A,20
02BC:  DATA 25,30
02BE:  DATA 32,58
02C0:  DATA 00,00
02C2:  DATA 0D,0A
02C4:  DATA 53,65
02C6:  DATA 6E,73
02C8:  DATA 69,72
02CA:  DATA 69,6F
02CC:  DATA 6E,20
02CE:  DATA 49,44
02D0:  DATA 20,44
02D2:  DATA 41,54
02D4:  DATA 41,5B
02D6:  DATA 35,5D
02D8:  DATA 3A,20
02DA:  DATA 25,30
02DC:  DATA 32,58
02DE:  DATA 00,00
02E0:  DATA 0D,0A
02E2:  DATA 53,65
02E4:  DATA 6E,73
02E6:  DATA 69,72
02E8:  DATA 69,6F
02EA:  DATA 6E,20
02EC:  DATA 49,44
02EE:  DATA 20,44
02F0:  DATA 41,54
02F2:  DATA 41,5B
02F4:  DATA 36,5D
02F6:  DATA 3A,20
02F8:  DATA 25,30
02FA:  DATA 32,58
02FC:  DATA 00,00
02FE:  DATA 0D,0A
0300:  DATA 53,65
0302:  DATA 6E,73
0304:  DATA 69,72
0306:  DATA 69,6F
0308:  DATA 6E,20
030A:  DATA 73,74
030C:  DATA 61,74
030E:  DATA 75,73
0310:  DATA 3A,20
0312:  DATA 25,75
0314:  DATA 00,00
0316:  DATA 0D,0A
0318:  DATA 53,65
031A:  DATA 6E,73
031C:  DATA 69,72
031E:  DATA 69,6F
0320:  DATA 6E,20
0322:  DATA 73,74
0324:  DATA 61,74
0326:  DATA 75,73
0328:  DATA 31,3A
032A:  DATA 20,25
032C:  DATA 75,00
032E:  DATA 0D,0A
0330:  DATA 53,65
0332:  DATA 6E,73
0334:  DATA 69,72
0336:  DATA 69,6F
0338:  DATA 6E,20
033A:  DATA 73,74
033C:  DATA 61,74
033E:  DATA 75,73
0340:  DATA 32,3A
0342:  DATA 20,25
0344:  DATA 75,00
0346:  DATA 0D,0A
0348:  DATA 44,69
034A:  DATA 66,66
034C:  DATA 65,72
034E:  DATA 65,6E
0350:  DATA 74,20
0352:  DATA 70,72
0354:  DATA 65,73
0356:  DATA 73,75
0358:  DATA 72,65
035A:  DATA 20,44
035C:  DATA 41,54
035E:  DATA 41,5B
0360:  DATA 30,5D
0362:  DATA 3A,20
0364:  DATA 25,30
0366:  DATA 32,58
0368:  DATA 00,00
036A:  DATA 0D,0A
036C:  DATA 44,69
036E:  DATA 66,66
0370:  DATA 65,72
0372:  DATA 65,6E
0374:  DATA 74,20
0376:  DATA 70,72
0378:  DATA 65,73
037A:  DATA 73,75
037C:  DATA 72,65
037E:  DATA 20,44
0380:  DATA 41,54
0382:  DATA 41,5B
0384:  DATA 31,5D
0386:  DATA 3A,20
0388:  DATA 25,30
038A:  DATA 32,58
038C:  DATA 00,00
038E:  DATA 0D,0A
0390:  DATA 44,69
0392:  DATA 66,66
0394:  DATA 65,72
0396:  DATA 65,6E
0398:  DATA 74,20
039A:  DATA 70,72
039C:  DATA 65,73
039E:  DATA 73,75
03A0:  DATA 72,65
03A2:  DATA 20,44
03A4:  DATA 41,54
03A6:  DATA 41,5B
03A8:  DATA 32,5D
03AA:  DATA 3A,20
03AC:  DATA 25,30
03AE:  DATA 32,58
03B0:  DATA 00,00
03B2:  DATA 0D,0A
03B4:  DATA 44,69
03B6:  DATA 66,66
03B8:  DATA 65,72
03BA:  DATA 65,6E
03BC:  DATA 74,20
03BE:  DATA 70,72
03C0:  DATA 65,73
03C2:  DATA 73,75
03C4:  DATA 72,65
03C6:  DATA 20,44
03C8:  DATA 41,54
03CA:  DATA 41,5B
03CC:  DATA 33,5D
03CE:  DATA 3A,20
03D0:  DATA 25,30
03D2:  DATA 32,58
03D4:  DATA 00,00
03D6:  DATA 0D,0A
03D8:  DATA 44,69
03DA:  DATA 66,66
03DC:  DATA 65,72
03DE:  DATA 65,6E
03E0:  DATA 74,20
03E2:  DATA 70,72
03E4:  DATA 65,73
03E6:  DATA 73,75
03E8:  DATA 72,65
03EA:  DATA 20,44
03EC:  DATA 41,54
03EE:  DATA 41,5B
03F0:  DATA 34,5D
03F2:  DATA 3A,20
03F4:  DATA 25,30
03F6:  DATA 32,58
03F8:  DATA 00,00
03FA:  DATA 0D,0A
03FC:  DATA 44,69
03FE:  DATA 66,66
0400:  DATA 65,72
0402:  DATA 65,6E
0404:  DATA 74,20
0406:  DATA 70,72
0408:  DATA 65,73
040A:  DATA 73,75
040C:  DATA 72,65
040E:  DATA 20,44
0410:  DATA 41,54
0412:  DATA 41,5B
0414:  DATA 35,5D
0416:  DATA 3A,20
0418:  DATA 25,30
041A:  DATA 32,58
041C:  DATA 00,00
041E:  DATA 0D,0A
0420:  DATA 44,69
0422:  DATA 66,66
0424:  DATA 65,72
0426:  DATA 65,6E
0428:  DATA 74,20
042A:  DATA 70,72
042C:  DATA 65,73
042E:  DATA 73,75
0430:  DATA 72,65
0432:  DATA 20,44
0434:  DATA 41,54
0436:  DATA 41,5B
0438:  DATA 36,5D
043A:  DATA 3A,20
043C:  DATA 25,30
043E:  DATA 32,58
0440:  DATA 00,00
0442:  DATA 0D,0A
0444:  DATA 44,69
0446:  DATA 66,66
0448:  DATA 65,72
044A:  DATA 65,6E
044C:  DATA 74,20
044E:  DATA 70,72
0450:  DATA 65,73
0452:  DATA 73,75
0454:  DATA 72,65
0456:  DATA 20,44
0458:  DATA 41,54
045A:  DATA 41,5B
045C:  DATA 37,5D
045E:  DATA 3A,20
0460:  DATA 25,30
0462:  DATA 32,58
0464:  DATA 00,00
0466:  DATA 0D,0A
0468:  DATA 44,69
046A:  DATA 66,66
046C:  DATA 65,72
046E:  DATA 65,6E
0470:  DATA 74,20
0472:  DATA 70,72
0474:  DATA 65,73
0476:  DATA 73,75
0478:  DATA 72,65
047A:  DATA 20,44
047C:  DATA 41,54
047E:  DATA 41,5B
0480:  DATA 38,5D
0482:  DATA 3A,20
0484:  DATA 25,30
0486:  DATA 32,58
0488:  DATA 00,00
048A:  DATA 0D,0A
048C:  DATA 44,69
048E:  DATA 66,66
0490:  DATA 65,72
0492:  DATA 65,6E
0494:  DATA 74,20
0496:  DATA 70,72
0498:  DATA 65,73
049A:  DATA 73,75
049C:  DATA 72,65
049E:  DATA 20,44
04A0:  DATA 41,54
04A2:  DATA 41,5B
04A4:  DATA 39,5D
04A6:  DATA 3A,20
04A8:  DATA 25,30
04AA:  DATA 32,58
04AC:  DATA 00,00
04AE:  DATA 0D,0A
04B0:  DATA 43,68
04B2:  DATA 65,63
04B4:  DATA 6B,20
04B6:  DATA 31,3A
04B8:  DATA 20,25
04BA:  DATA 30,32
04BC:  DATA 58,00
04BE:  DATA 0D,0A
04C0:  DATA 43,68
04C2:  DATA 65,63
04C4:  DATA 6B,20
04C6:  DATA 32,3A
04C8:  DATA 20,25
04CA:  DATA 30,32
04CC:  DATA 58,00
04CE:  DATA 0D,0A
04D0:  DATA 43,68
04D2:  DATA 65,63
04D4:  DATA 6B,20
04D6:  DATA 33,3A
04D8:  DATA 20,25
04DA:  DATA 30,32
04DC:  DATA 58,00
04DE:  DATA 0D,0A
04E0:  DATA 53,63
04E2:  DATA 61,6C
04E4:  DATA 65,20
04E6:  DATA 66,61
04E8:  DATA 63,74
04EA:  DATA 6F,72
04EC:  DATA 20,76
04EE:  DATA 61,6C
04F0:  DATA 75,65
04F2:  DATA 3A,20
04F4:  DATA 25,4C
04F6:  DATA 64,00
04F8:  DATA 0D,0A
04FA:  DATA 54,65
04FC:  DATA 6D,70
04FE:  DATA 65,61
0500:  DATA 74,75
0502:  DATA 72,65
0504:  DATA 20,76
0506:  DATA 61,6C
0508:  DATA 75,65
050A:  DATA 3A,20
050C:  DATA 25,33
050E:  DATA 2E,31
0510:  DATA 66,00
0512:  DATA 0D,0A
0514:  DATA 50,72
0516:  DATA 65,73
0518:  DATA 73,75
051A:  DATA 72,65
051C:  DATA 20,76
051E:  DATA 61,6C
0520:  DATA 75,65
0522:  DATA 3A,20
0524:  DATA 25,33
0526:  DATA 2E,31
0528:  DATA 66,00
*
0536:  DATA 0D,0A
0538:  DATA 0D,0A
053A:  DATA 43,43
053C:  DATA 53,20
053E:  DATA 43,41
0540:  DATA 4E,20
0542:  DATA 45,58
0544:  DATA 41,4D
0546:  DATA 50,4C
0548:  DATA 45,0D
054A:  DATA 0A,00
054C:  DATA 0D,0A
054E:  DATA 52,75
0550:  DATA 6E,6E
0552:  DATA 69,6E
0554:  DATA 67,2E
0556:  DATA 2E,2E
0558:  DATA 00,00
055A:  DATA 0D,0A
055C:  DATA 50,72
055E:  DATA 65,73
0560:  DATA 73,75
0562:  DATA 72,65
0564:  DATA 20,76
0566:  DATA 61,6C
0568:  DATA 75,65
056A:  DATA 3A,20
056C:  DATA 25,33
056E:  DATA 2E,31
0570:  DATA 66,00
0572:  DATA 0D,0A
0574:  DATA 50,55
0576:  DATA 54,20
0578:  DATA 25,55
057A:  DATA 3A,20
057C:  DATA 49,44
057E:  DATA 3D,25
0580:  DATA 4C,55
0582:  DATA 20,4C
0584:  DATA 45,4E
0586:  DATA 3D,25
0588:  DATA 55,20
058A:  DATA 00,00
058C:  DATA 50,52
058E:  DATA 49,3D
0590:  DATA 25,55
0592:  DATA 20,45
0594:  DATA 58,54
0596:  DATA 3D,25
0598:  DATA 55,20
059A:  DATA 52,54
059C:  DATA 52,3D
059E:  DATA 25,55
05A0:  DATA 0D,0A
05A2:  DATA 20,20
05A4:  DATA 20,44
05A6:  DATA 41,54
05A8:  DATA 41,20
05AA:  DATA 3D,20
05AC:  DATA 00,00
05AE:  DATA 0D,0A
05B0:  DATA 46,41
05B2:  DATA 49,4C
05B4:  DATA 20,6F
05B6:  DATA 6E,20
05B8:  DATA 50,55
05BA:  DATA 54,44
05BC:  DATA 0D,0A
05BE:  DATA 00,00
05C0:  TBLRD*+
05C2:  MOVF   FF5,F
05C4:  BZ    05E0
05C6:  MOVFF  FF6,41
05CA:  MOVFF  FF7,42
05CE:  MOVF   FF5,W
05D0:  BTFSS  F9E.4
05D2:  BRA    05D0
05D4:  MOVWF  FAD
05D6:  MOVFF  41,FF6
05DA:  MOVFF  42,FF7
05DE:  BRA    05C0
05E0:  RETURN 0
*
0882:  TBLRD*+
0884:  MOVFF  FF6,5F
0888:  MOVFF  FF7,60
088C:  MOVF   FF5,W
088E:  BTFSS  F9E.4
0890:  BRA    088E
0892:  MOVWF  FAD
0894:  MOVFF  5F,FF6
0898:  MOVFF  60,FF7
089C:  DECFSZ 5E,F
089E:  BRA    0882
08A0:  RETURN 0
08A2:  MOVF   47,W
08A4:  CLRF   01
08A6:  SUBWF  46,W
08A8:  BC    08B0
08AA:  MOVFF  46,00
08AE:  BRA    08C8
08B0:  CLRF   00
08B2:  MOVLW  08
08B4:  MOVWF  48
08B6:  RLCF   46,F
08B8:  RLCF   00,F
08BA:  MOVF   47,W
08BC:  SUBWF  00,W
08BE:  BTFSC  FD8.0
08C0:  MOVWF  00
08C2:  RLCF   01,F
08C4:  DECFSZ 48,F
08C6:  BRA    08B6
08C8:  RETURN 0
08CA:  MOVF   01,W
08CC:  MOVFF  44,46
08D0:  MOVLW  64
08D2:  MOVWF  47
08D4:  RCALL  08A2
08D6:  MOVFF  00,44
08DA:  MOVF   01,W
08DC:  MOVLW  30
08DE:  BNZ   08EE
08E0:  BTFSS  45.1
08E2:  BRA    08FE
08E4:  BTFSC  45.3
08E6:  BRA    08FE
08E8:  BTFSC  45.4
08EA:  MOVLW  20
08EC:  BRA    08F4
08EE:  BCF    45.3
08F0:  BCF    45.4
08F2:  BSF    45.0
08F4:  ADDWF  01,F
08F6:  MOVF   01,W
08F8:  BTFSS  F9E.4
08FA:  BRA    08F8
08FC:  MOVWF  FAD
08FE:  MOVFF  44,46
0902:  MOVLW  0A
0904:  MOVWF  47
0906:  RCALL  08A2
0908:  MOVFF  00,44
090C:  MOVF   01,W
090E:  MOVLW  30
0910:  BNZ   091E
0912:  BTFSC  45.3
0914:  BRA    0928
0916:  BTFSS  45.0
0918:  BRA    0928
091A:  BTFSC  45.4
091C:  MOVLW  20
091E:  ADDWF  01,F
0920:  MOVF   01,W
0922:  BTFSS  F9E.4
0924:  BRA    0922
0926:  MOVWF  FAD
0928:  MOVLW  30
092A:  ADDWF  44,F
092C:  MOVF   44,W
092E:  BTFSS  F9E.4
0930:  BRA    092E
0932:  MOVWF  FAD
0934:  RETURN 0
*
0A26:  BTFSC  5F.7
0A28:  BRA    0A4A
0A2A:  MOVLW  0F
0A2C:  MOVWF  00
0A2E:  SWAPF  5E,W
0A30:  ANDWF  00,F
0A32:  MOVLW  0A
0A34:  SUBWF  00,W
0A36:  BC    0A3E
0A38:  MOVLW  30
0A3A:  ADDWF  00,F
0A3C:  BRA    0A42
0A3E:  MOVF   5F,W
0A40:  ADDWF  00,F
0A42:  MOVF   00,W
0A44:  BTFSS  F9E.4
0A46:  BRA    0A44
0A48:  MOVWF  FAD
0A4A:  MOVLW  0F
0A4C:  ANDWF  5E,F
0A4E:  MOVLW  0A
0A50:  SUBWF  5E,W
0A52:  BC    0A58
0A54:  MOVLW  30
0A56:  BRA    0A5C
0A58:  BCF    5F.7
0A5A:  MOVF   5F,W
0A5C:  ADDWF  5E,F
0A5E:  MOVF   5E,W
0A60:  BTFSS  F9E.4
0A62:  BRA    0A60
0A64:  MOVWF  FAD
0A66:  RETURN 0
*
0AAA:  MOVLW  8E
0AAC:  MOVWF  00
0AAE:  MOVFF  5F,01
0AB2:  MOVFF  5E,02
0AB6:  CLRF   03
0AB8:  BTFSS  5F.7
0ABA:  BRA    0AC6
0ABC:  COMF   01,F
0ABE:  COMF   02,F
0AC0:  INCF   02,F
0AC2:  BNZ   0AC6
0AC4:  INCF   01,F
0AC6:  MOVF   01,F
0AC8:  BNZ   0ADC
0ACA:  MOVFF  02,01
0ACE:  CLRF   02
0AD0:  MOVLW  08
0AD2:  SUBWF  00,F
0AD4:  MOVF   01,F
0AD6:  BNZ   0ADC
0AD8:  CLRF   00
0ADA:  BRA    0AF0
0ADC:  BCF    FD8.0
0ADE:  BTFSC  01.7
0AE0:  BRA    0AEA
0AE2:  RLCF   02,F
0AE4:  RLCF   01,F
0AE6:  DECF   00,F
0AE8:  BRA    0ADC
0AEA:  BTFSC  5F.7
0AEC:  BRA    0AF0
0AEE:  BCF    01.7
0AF0:  RETURN 0
0AF2:  MOVF   x62,W
0AF4:  BTFSC  FD8.2
0AF6:  BRA    0C42
0AF8:  MOVWF  x6E
0AFA:  MOVF   x66,W
0AFC:  BTFSC  FD8.2
0AFE:  BRA    0C42
0B00:  SUBWF  x6E,F
0B02:  BNC   0B0E
0B04:  MOVLW  7F
0B06:  ADDWF  x6E,F
0B08:  BTFSC  FD8.0
0B0A:  BRA    0C42
0B0C:  BRA    0B1A
0B0E:  MOVLW  81
0B10:  SUBWF  x6E,F
0B12:  BTFSS  FD8.0
0B14:  BRA    0C42
0B16:  BTFSC  FD8.2
0B18:  BRA    0C42
0B1A:  MOVFF  6E,00
0B1E:  CLRF   01
0B20:  CLRF   02
0B22:  CLRF   03
0B24:  CLRF   x6D
0B26:  MOVFF  63,6C
0B2A:  BSF    x6C.7
0B2C:  MOVFF  64,6B
0B30:  MOVFF  65,6A
0B34:  MOVLW  19
0B36:  MOVWF  x6E
0B38:  MOVF   x69,W
0B3A:  SUBWF  x6A,F
0B3C:  BC    0B58
0B3E:  MOVLW  01
0B40:  SUBWF  x6B,F
0B42:  BC    0B58
0B44:  SUBWF  x6C,F
0B46:  BC    0B58
0B48:  SUBWF  x6D,F
0B4A:  BC    0B58
0B4C:  INCF   x6D,F
0B4E:  INCF   x6C,F
0B50:  INCF   x6B,F
0B52:  MOVF   x69,W
0B54:  ADDWF  x6A,F
0B56:  BRA    0BA8
0B58:  MOVF   x68,W
0B5A:  SUBWF  x6B,F
0B5C:  BC    0B82
0B5E:  MOVLW  01
0B60:  SUBWF  x6C,F
0B62:  BC    0B82
0B64:  SUBWF  x6D,F
0B66:  BC    0B82
0B68:  INCF   x6D,F
0B6A:  INCF   x6C,F
0B6C:  MOVF   x68,W
0B6E:  ADDWF  x6B,F
0B70:  MOVF   x69,W
0B72:  ADDWF  x6A,F
0B74:  BNC   0BA8
0B76:  INCF   x6B,F
0B78:  BNZ   0BA8
0B7A:  INCF   x6C,F
0B7C:  BNZ   0BA8
0B7E:  INCF   x6D,F
0B80:  BRA    0BA8
0B82:  MOVF   x67,W
0B84:  IORLW  80
0B86:  SUBWF  x6C,F
0B88:  BC    0BA6
0B8A:  MOVLW  01
0B8C:  SUBWF  x6D,F
0B8E:  BC    0BA6
0B90:  INCF   x6D,F
0B92:  MOVF   x67,W
0B94:  IORLW  80
0B96:  ADDWF  x6C,F
0B98:  MOVF   x68,W
0B9A:  ADDWF  x6B,F
0B9C:  BNC   0B70
0B9E:  INCF   x6C,F
0BA0:  BNZ   0B70
0BA2:  INCF   x6D,F
0BA4:  BRA    0B70
0BA6:  BSF    03.0
0BA8:  DECFSZ x6E,F
0BAA:  BRA    0BAE
0BAC:  BRA    0BC4
0BAE:  BCF    FD8.0
0BB0:  RLCF   x6A,F
0BB2:  RLCF   x6B,F
0BB4:  RLCF   x6C,F
0BB6:  RLCF   x6D,F
0BB8:  BCF    FD8.0
0BBA:  RLCF   03,F
0BBC:  RLCF   02,F
0BBE:  RLCF   01,F
0BC0:  RLCF   x6F,F
0BC2:  BRA    0B38
0BC4:  BTFSS  x6F.0
0BC6:  BRA    0BD4
0BC8:  BCF    FD8.0
0BCA:  RRCF   01,F
0BCC:  RRCF   02,F
0BCE:  RRCF   03,F
0BD0:  RRCF   x6F,F
0BD2:  BRA    0BD8
0BD4:  DECF   00,F
0BD6:  BZ    0C42
0BD8:  BTFSC  x6F.7
0BDA:  BRA    0C18
0BDC:  BCF    FD8.0
0BDE:  RLCF   x6A,F
0BE0:  RLCF   x6B,F
0BE2:  RLCF   x6C,F
0BE4:  RLCF   x6D,F
0BE6:  MOVF   x69,W
0BE8:  SUBWF  x6A,F
0BEA:  BC    0BFA
0BEC:  MOVLW  01
0BEE:  SUBWF  x6B,F
0BF0:  BC    0BFA
0BF2:  SUBWF  x6C,F
0BF4:  BC    0BFA
0BF6:  SUBWF  x6D,F
0BF8:  BNC   0C2E
0BFA:  MOVF   x68,W
0BFC:  SUBWF  x6B,F
0BFE:  BC    0C0A
0C00:  MOVLW  01
0C02:  SUBWF  x6C,F
0C04:  BC    0C0A
0C06:  SUBWF  x6D,F
0C08:  BNC   0C2E
0C0A:  MOVF   x67,W
0C0C:  IORLW  80
0C0E:  SUBWF  x6C,F
0C10:  BC    0C18
0C12:  MOVLW  01
0C14:  SUBWF  x6D,F
0C16:  BNC   0C2E
0C18:  INCF   03,F
0C1A:  BNZ   0C2E
0C1C:  INCF   02,F
0C1E:  BNZ   0C2E
0C20:  INCF   01,F
0C22:  BNZ   0C2E
0C24:  INCF   00,F
0C26:  BZ    0C42
0C28:  RRCF   01,F
0C2A:  RRCF   02,F
0C2C:  RRCF   03,F
0C2E:  MOVFF  63,6E
0C32:  MOVF   x67,W
0C34:  XORWF  x6E,F
0C36:  BTFSS  x6E.7
0C38:  BRA    0C3E
0C3A:  BSF    01.7
0C3C:  BRA    0C4A
0C3E:  BCF    01.7
0C40:  BRA    0C4A
0C42:  CLRF   00
0C44:  CLRF   01
0C46:  CLRF   02
0C48:  CLRF   03
0C4A:  RETURN 0
0C4C:  MOVLW  8E
0C4E:  MOVWF  00
0C50:  MOVFF  63,01
0C54:  MOVFF  62,02
0C58:  CLRF   03
0C5A:  MOVF   01,F
0C5C:  BNZ   0C70
0C5E:  MOVFF  02,01
0C62:  CLRF   02
0C64:  MOVLW  08
0C66:  SUBWF  00,F
0C68:  MOVF   01,F
0C6A:  BNZ   0C70
0C6C:  CLRF   00
0C6E:  BRA    0C80
0C70:  BCF    FD8.0
0C72:  BTFSC  01.7
0C74:  BRA    0C7E
0C76:  RLCF   02,F
0C78:  RLCF   01,F
0C7A:  DECF   00,F
0C7C:  BRA    0C70
0C7E:  BCF    01.7
0C80:  GOTO   1346 (RETURN)
0C84:  MOVFF  FEA,66
0C88:  MOVFF  FE9,65
0C8C:  BTFSS  5F.7
0C8E:  BRA    0CA0
0C90:  BSF    x65.7
0C92:  BTFSS  x65.4
0C94:  INCF   x65,F
0C96:  COMF   5E,F
0C98:  COMF   5F,F
0C9A:  INCF   5E,F
0C9C:  BTFSC  FD8.2
0C9E:  INCF   5F,F
0CA0:  SWAPF  5F,W
0CA2:  IORLW  F0
0CA4:  MOVWF  x61
0CA6:  ADDWF  x61,F
0CA8:  ADDLW  E2
0CAA:  MOVWF  x62
0CAC:  ADDLW  32
0CAE:  MOVWF  x64
0CB0:  MOVF   5F,W
0CB2:  ANDLW  0F
0CB4:  ADDWF  x62,F
0CB6:  ADDWF  x62,F
0CB8:  ADDWF  x64,F
0CBA:  ADDLW  E9
0CBC:  MOVWF  x63
0CBE:  ADDWF  x63,F
0CC0:  ADDWF  x63,F
0CC2:  SWAPF  5E,W
0CC4:  ANDLW  0F
0CC6:  ADDWF  x63,F
0CC8:  ADDWF  x64,F
0CCA:  RLCF   x63,F
0CCC:  RLCF   x64,F
0CCE:  COMF   x64,F
0CD0:  RLCF   x64,F
0CD2:  MOVF   5E,W
0CD4:  ANDLW  0F
0CD6:  ADDWF  x64,F
0CD8:  RLCF   x61,F
0CDA:  MOVLW  07
0CDC:  MOVWF  x60
0CDE:  MOVLW  0A
0CE0:  DECF   x63,F
0CE2:  ADDWF  x64,F
0CE4:  BNC   0CE0
0CE6:  DECF   x62,F
0CE8:  ADDWF  x63,F
0CEA:  BNC   0CE6
0CEC:  DECF   x61,F
0CEE:  ADDWF  x62,F
0CF0:  BNC   0CEC
0CF2:  DECF   x60,F
0CF4:  ADDWF  x61,F
0CF6:  BNC   0CF2
0CF8:  CLRF   FEA
0CFA:  MOVLW  60
0CFC:  MOVWF  FE9
0CFE:  MOVLW  07
0D00:  ANDWF  x65,W
0D02:  BCF    x65.6
0D04:  MOVF   FED,F
0D06:  ANDWF  x65,W
0D08:  BNZ   0D18
0D0A:  BTFSC  x65.4
0D0C:  MOVF   FEE,F
0D0E:  BTFSC  x65.4
0D10:  BRA    0D18
0D12:  MOVLW  20
0D14:  MOVWF  00
0D16:  BRA    0D58
0D18:  ADDWF  FE9,F
0D1A:  MOVLW  00
0D1C:  ADDWFC FEA,F
0D1E:  MOVF   FE9,W
0D20:  SUBLW  64
0D22:  BNZ   0D2A
0D24:  MOVF   FEA,F
0D26:  BNZ   0D2A
0D28:  BSF    x65.6
0D2A:  MOVF   FEF,W
0D2C:  MOVWF  00
0D2E:  BNZ   0D40
0D30:  BTFSC  x65.6
0D32:  BRA    0D40
0D34:  BTFSC  x65.4
0D36:  BRA    0D60
0D38:  BTFSC  x65.3
0D3A:  BRA    0D40
0D3C:  MOVLW  20
0D3E:  BRA    0D56
0D40:  BTFSS  x65.7
0D42:  BRA    0D50
0D44:  MOVLW  2D
0D46:  MOVWF  00
0D48:  MOVF   FED,W
0D4A:  BCF    x65.6
0D4C:  BCF    x65.7
0D4E:  BRA    0D58
0D50:  BSF    x65.3
0D52:  BCF    x65.4
0D54:  MOVLW  30
0D56:  ADDWF  00,F
0D58:  MOVF   00,W
0D5A:  BTFSS  F9E.4
0D5C:  BRA    0D5A
0D5E:  MOVWF  FAD
0D60:  MOVF   FEE,W
0D62:  BTFSS  x65.6
0D64:  BRA    0D1E
0D66:  GOTO   1398 (RETURN)
0D6A:  MOVF   x6B,W
0D6C:  BTFSC  FD8.2
0D6E:  BRA    0E52
0D70:  MOVWF  00
0D72:  MOVF   x6F,W
0D74:  BTFSC  FD8.2
0D76:  BRA    0E52
0D78:  ADDWF  00,F
0D7A:  BNC   0D84
0D7C:  MOVLW  81
0D7E:  ADDWF  00,F
0D80:  BC    0E52
0D82:  BRA    0D8C
0D84:  MOVLW  7F
0D86:  SUBWF  00,F
0D88:  BNC   0E52
0D8A:  BZ    0E52
0D8C:  MOVFF  6C,73
0D90:  MOVF   x70,W
0D92:  XORWF  x73,F
0D94:  BSF    x6C.7
0D96:  BSF    x70.7
0D98:  MOVF   x6E,W
0D9A:  MULWF  x72
0D9C:  MOVFF  FF4,75
0DA0:  MOVF   x6D,W
0DA2:  MULWF  x71
0DA4:  MOVFF  FF4,03
0DA8:  MOVFF  FF3,74
0DAC:  MULWF  x72
0DAE:  MOVF   FF3,W
0DB0:  ADDWF  x75,F
0DB2:  MOVF   FF4,W
0DB4:  ADDWFC x74,F
0DB6:  MOVLW  00
0DB8:  ADDWFC 03,F
0DBA:  MOVF   x6E,W
0DBC:  MULWF  x71
0DBE:  MOVF   FF3,W
0DC0:  ADDWF  x75,F
0DC2:  MOVF   FF4,W
0DC4:  ADDWFC x74,F
0DC6:  MOVLW  00
0DC8:  CLRF   02
0DCA:  ADDWFC 03,F
0DCC:  ADDWFC 02,F
0DCE:  MOVF   x6C,W
0DD0:  MULWF  x72
0DD2:  MOVF   FF3,W
0DD4:  ADDWF  x74,F
0DD6:  MOVF   FF4,W
0DD8:  ADDWFC 03,F
0DDA:  MOVLW  00
0DDC:  ADDWFC 02,F
0DDE:  MOVF   x6C,W
0DE0:  MULWF  x71
0DE2:  MOVF   FF3,W
0DE4:  ADDWF  03,F
0DE6:  MOVF   FF4,W
0DE8:  ADDWFC 02,F
0DEA:  MOVLW  00
0DEC:  CLRF   01
0DEE:  ADDWFC 01,F
0DF0:  MOVF   x6E,W
0DF2:  MULWF  x70
0DF4:  MOVF   FF3,W
0DF6:  ADDWF  x74,F
0DF8:  MOVF   FF4,W
0DFA:  ADDWFC 03,F
0DFC:  MOVLW  00
0DFE:  ADDWFC 02,F
0E00:  ADDWFC 01,F
0E02:  MOVF   x6D,W
0E04:  MULWF  x70
0E06:  MOVF   FF3,W
0E08:  ADDWF  03,F
0E0A:  MOVF   FF4,W
0E0C:  ADDWFC 02,F
0E0E:  MOVLW  00
0E10:  ADDWFC 01,F
0E12:  MOVF   x6C,W
0E14:  MULWF  x70
0E16:  MOVF   FF3,W
0E18:  ADDWF  02,F
0E1A:  MOVF   FF4,W
0E1C:  ADDWFC 01,F
0E1E:  INCF   00,F
0E20:  BTFSC  01.7
0E22:  BRA    0E2E
0E24:  RLCF   x74,F
0E26:  RLCF   03,F
0E28:  RLCF   02,F
0E2A:  RLCF   01,F
0E2C:  DECF   00,F
0E2E:  MOVLW  00
0E30:  BTFSS  x74.7
0E32:  BRA    0E48
0E34:  INCF   03,F
0E36:  ADDWFC 02,F
0E38:  ADDWFC 01,F
0E3A:  MOVF   01,W
0E3C:  BNZ   0E48
0E3E:  MOVF   02,W
0E40:  BNZ   0E48
0E42:  MOVF   03,W
0E44:  BNZ   0E48
0E46:  INCF   00,F
0E48:  BTFSC  x73.7
0E4A:  BSF    01.7
0E4C:  BTFSS  x73.7
0E4E:  BCF    01.7
0E50:  BRA    0E5A
0E52:  CLRF   00
0E54:  CLRF   01
0E56:  CLRF   02
0E58:  CLRF   03
0E5A:  GOTO   0F54 (RETURN)
0E5E:  MOVF   x6B,W
0E60:  SUBLW  B6
0E62:  MOVWF  x6B
0E64:  CLRF   03
0E66:  MOVFF  6C,6F
0E6A:  BSF    x6C.7
0E6C:  BCF    FD8.0
0E6E:  RRCF   x6C,F
0E70:  RRCF   x6D,F
0E72:  RRCF   x6E,F
0E74:  RRCF   03,F
0E76:  RRCF   02,F
0E78:  RRCF   01,F
0E7A:  RRCF   00,F
0E7C:  DECFSZ x6B,F
0E7E:  BRA    0E6C
0E80:  BTFSS  x6F.7
0E82:  BRA    0E9A
0E84:  COMF   00,F
0E86:  COMF   01,F
0E88:  COMF   02,F
0E8A:  COMF   03,F
0E8C:  INCF   00,F
0E8E:  BTFSC  FD8.2
0E90:  INCF   01,F
0E92:  BTFSC  FD8.2
0E94:  INCF   02,F
0E96:  BTFSC  FD8.2
0E98:  INCF   03,F
0E9A:  GOTO   0F7A (RETURN)
0E9E:  BTFSC  FD8.1
0EA0:  BRA    0EA8
0EA2:  CLRF   FEA
0EA4:  MOVLW  73
0EA6:  MOVWF  FE9
0EA8:  CLRF   00
0EAA:  CLRF   01
0EAC:  CLRF   02
0EAE:  CLRF   03
0EB0:  CLRF   x73
0EB2:  CLRF   x74
0EB4:  CLRF   x75
0EB6:  CLRF   x76
0EB8:  MOVF   x72,W
0EBA:  IORWF  x71,W
0EBC:  IORWF  x70,W
0EBE:  IORWF  x6F,W
0EC0:  BZ    0F1A
0EC2:  MOVLW  20
0EC4:  MOVWF  x77
0EC6:  BCF    FD8.0
0EC8:  RLCF   x6B,F
0ECA:  RLCF   x6C,F
0ECC:  RLCF   x6D,F
0ECE:  RLCF   x6E,F
0ED0:  RLCF   x73,F
0ED2:  RLCF   x74,F
0ED4:  RLCF   x75,F
0ED6:  RLCF   x76,F
0ED8:  MOVF   x72,W
0EDA:  SUBWF  x76,W
0EDC:  BNZ   0EEE
0EDE:  MOVF   x71,W
0EE0:  SUBWF  x75,W
0EE2:  BNZ   0EEE
0EE4:  MOVF   x70,W
0EE6:  SUBWF  x74,W
0EE8:  BNZ   0EEE
0EEA:  MOVF   x6F,W
0EEC:  SUBWF  x73,W
0EEE:  BNC   0F0E
0EF0:  MOVF   x6F,W
0EF2:  SUBWF  x73,F
0EF4:  MOVF   x70,W
0EF6:  BTFSS  FD8.0
0EF8:  INCFSZ x70,W
0EFA:  SUBWF  x74,F
0EFC:  MOVF   x71,W
0EFE:  BTFSS  FD8.0
0F00:  INCFSZ x71,W
0F02:  SUBWF  x75,F
0F04:  MOVF   x72,W
0F06:  BTFSS  FD8.0
0F08:  INCFSZ x72,W
0F0A:  SUBWF  x76,F
0F0C:  BSF    FD8.0
0F0E:  RLCF   00,F
0F10:  RLCF   01,F
0F12:  RLCF   02,F
0F14:  RLCF   03,F
0F16:  DECFSZ x77,F
0F18:  BRA    0EC6
0F1A:  MOVFF  73,FEF
0F1E:  MOVFF  74,FEC
0F22:  MOVFF  75,FEC
0F26:  MOVFF  76,FEC
0F2A:  RETURN 0
0F2C:  MOVF   FE9,W
0F2E:  MOVWF  x63
0F30:  MOVF   x62,W
0F32:  MOVWF  x65
0F34:  BZ    0F68
0F36:  MOVFF  61,6E
0F3A:  MOVFF  60,6D
0F3E:  MOVFF  5F,6C
0F42:  MOVFF  5E,6B
0F46:  CLRF   x72
0F48:  CLRF   x71
0F4A:  MOVLW  20
0F4C:  MOVWF  x70
0F4E:  MOVLW  82
0F50:  MOVWF  x6F
0F52:  BRA    0D6A
0F54:  MOVFF  03,61
0F58:  MOVFF  02,60
0F5C:  MOVFF  01,5F
0F60:  MOVFF  00,5E
0F64:  DECFSZ x65,F
0F66:  BRA    0F36
0F68:  MOVFF  61,6E
0F6C:  MOVFF  60,6D
0F70:  MOVFF  5F,6C
0F74:  MOVFF  5E,6B
0F78:  BRA    0E5E
0F7A:  MOVFF  03,61
0F7E:  MOVFF  02,60
0F82:  MOVFF  01,5F
0F86:  MOVFF  00,5E
0F8A:  BTFSS  x61.7
0F8C:  BRA    0FA8
0F8E:  DECF   x63,F
0F90:  BSF    x63.5
0F92:  COMF   5E,F
0F94:  COMF   5F,F
0F96:  COMF   x60,F
0F98:  COMF   x61,F
0F9A:  INCF   5E,F
0F9C:  BTFSC  FD8.2
0F9E:  INCF   5F,F
0FA0:  BTFSC  FD8.2
0FA2:  INCF   x60,F
0FA4:  BTFSC  FD8.2
0FA6:  INCF   x61,F
0FA8:  MOVLW  3B
0FAA:  MOVWF  x6A
0FAC:  MOVLW  9A
0FAE:  MOVWF  x69
0FB0:  MOVLW  CA
0FB2:  MOVWF  x68
0FB4:  CLRF   x67
0FB6:  MOVLW  0A
0FB8:  MOVWF  x65
0FBA:  MOVF   x62,W
0FBC:  BTFSC  FD8.2
0FBE:  INCF   x63,F
0FC0:  BSF    FD8.1
0FC2:  CLRF   FEA
0FC4:  MOVLW  5E
0FC6:  MOVWF  FE9
0FC8:  MOVFF  61,6E
0FCC:  MOVFF  60,6D
0FD0:  MOVFF  5F,6C
0FD4:  MOVFF  5E,6B
0FD8:  MOVFF  6A,72
0FDC:  MOVFF  69,71
0FE0:  MOVFF  68,70
0FE4:  MOVFF  67,6F
0FE8:  RCALL  0E9E
0FEA:  MOVF   01,W
0FEC:  MOVF   00,F
0FEE:  BNZ   100E
0FF0:  INCF   x62,W
0FF2:  SUBWF  x65,W
0FF4:  BZ    100E
0FF6:  MOVF   x63,W
0FF8:  BZ    1012
0FFA:  ANDLW  0F
0FFC:  SUBWF  x65,W
0FFE:  BZ    1002
1000:  BC    1078
1002:  BTFSC  x63.7
1004:  BRA    1078
1006:  BTFSC  x63.6
1008:  BRA    1012
100A:  MOVLW  20
100C:  BRA    106E
100E:  MOVLW  20
1010:  ANDWF  x63,F
1012:  BTFSS  x63.5
1014:  BRA    1030
1016:  BCF    x63.5
1018:  MOVF   x62,W
101A:  BTFSS  FD8.2
101C:  DECF   x63,F
101E:  MOVF   00,W
1020:  MOVWF  x63
1022:  MOVLW  2D
1024:  BTFSS  F9E.4
1026:  BRA    1024
1028:  MOVWF  FAD
102A:  MOVF   x63,W
102C:  MOVWF  00
102E:  CLRF   x63
1030:  MOVF   x62,W
1032:  SUBWF  x65,W
1034:  BNZ   104C
1036:  MOVF   00,W
1038:  MOVWF  x63
103A:  MOVLW  2E
103C:  BTFSS  F9E.4
103E:  BRA    103C
1040:  MOVWF  FAD
1042:  MOVF   x63,W
1044:  MOVWF  00
1046:  MOVLW  20
1048:  ANDWF  x63,F
104A:  MOVLW  00
104C:  MOVLW  30
104E:  BTFSS  x63.5
1050:  BRA    106E
1052:  BCF    x63.5
1054:  MOVF   x62,W
1056:  BTFSS  FD8.2
1058:  DECF   x63,F
105A:  MOVF   00,W
105C:  MOVWF  x63
105E:  MOVLW  2D
1060:  BTFSS  F9E.4
1062:  BRA    1060
1064:  MOVWF  FAD
1066:  MOVF   x63,W
1068:  MOVWF  00
106A:  CLRF   x63
106C:  MOVLW  30
106E:  ADDWF  00,F
1070:  MOVF   00,W
1072:  BTFSS  F9E.4
1074:  BRA    1072
1076:  MOVWF  FAD
1078:  BCF    FD8.1
107A:  MOVFF  6A,6E
107E:  MOVFF  69,6D
1082:  MOVFF  68,6C
1086:  MOVFF  67,6B
108A:  CLRF   x72
108C:  CLRF   x71
108E:  CLRF   x70
1090:  MOVLW  0A
1092:  MOVWF  x6F
1094:  RCALL  0E9E
1096:  MOVFF  03,6A
109A:  MOVFF  02,69
109E:  MOVFF  01,68
10A2:  MOVFF  00,67
10A6:  DECFSZ x65,F
10A8:  BRA    0FC0
10AA:  RETURN 0
*
14C2:  MOVF   FE9,W
14C4:  MOVWF  45
14C6:  MOVLW  3B
14C8:  MOVWF  4C
14CA:  MOVLW  9A
14CC:  MOVWF  4B
14CE:  MOVLW  CA
14D0:  MOVWF  4A
14D2:  CLRF   49
14D4:  MOVLW  0A
14D6:  MOVWF  47
14D8:  BSF    FD8.1
14DA:  CLRF   FEA
14DC:  MOVLW  41
14DE:  MOVWF  FE9
14E0:  MOVFF  44,6E
14E4:  MOVFF  43,6D
14E8:  MOVFF  42,6C
14EC:  MOVFF  41,6B
14F0:  MOVFF  4C,72
14F4:  MOVFF  4B,71
14F8:  MOVFF  4A,70
14FC:  MOVFF  49,6F
1500:  RCALL  0E9E
1502:  MOVF   01,W
1504:  MOVF   00,F
1506:  BNZ   1526
1508:  MOVF   47,W
150A:  XORLW  01
150C:  BZ    1526
150E:  MOVF   45,W
1510:  BZ    1528
1512:  ANDLW  0F
1514:  SUBWF  47,W
1516:  BZ    151A
1518:  BC    1534
151A:  BTFSC  45.7
151C:  BRA    1534
151E:  BTFSC  45.6
1520:  BRA    1528
1522:  MOVLW  20
1524:  BRA    152A
1526:  CLRF   45
1528:  MOVLW  30
152A:  ADDWF  00,F
152C:  MOVF   00,W
152E:  BTFSS  F9E.4
1530:  BRA    152E
1532:  MOVWF  FAD
1534:  BCF    FD8.1
1536:  MOVFF  4C,6E
153A:  MOVFF  4B,6D
153E:  MOVFF  4A,6C
1542:  MOVFF  49,6B
1546:  CLRF   x72
1548:  CLRF   x71
154A:  CLRF   x70
154C:  MOVLW  0A
154E:  MOVWF  x6F
1550:  RCALL  0E9E
1552:  MOVFF  03,4C
1556:  MOVFF  02,4B
155A:  MOVFF  01,4A
155E:  MOVFF  00,49
1562:  DECFSZ 47,F
1564:  BRA    14D8
1566:  GOTO   174C (RETURN)
....................  
.................... #list 
....................  
.................... //#include <16F887.h> 
.................... #fuses HS,NOPROTECT,NOLVP,NOWDT 
.................... #use delay(clock=20000000) 
*
05E2:  CLRF   FEA
05E4:  MOVLW  5E
05E6:  MOVWF  FE9
05E8:  MOVF   FEF,W
05EA:  BZ    0606
05EC:  MOVLW  06
05EE:  MOVWF  01
05F0:  CLRF   00
05F2:  DECFSZ 00,F
05F4:  BRA    05F2
05F6:  DECFSZ 01,F
05F8:  BRA    05F0
05FA:  MOVLW  7B
05FC:  MOVWF  00
05FE:  DECFSZ 00,F
0600:  BRA    05FE
0602:  DECFSZ FEF,F
0604:  BRA    05EC
0606:  RETURN 0
.................... #use i2c(Master, sda=PIN_C4, scl=PIN_C3,fast= 500000, FORCE_HW)  // FORCE_SW 
*
0866:  BCF    FC6.7
0868:  BCF    F9E.3
086A:  MOVFF  5E,FC9
086E:  MOVLW  02
0870:  BTFSC  FC6.7
0872:  BRA    087E
0874:  BTFSS  F9E.3
0876:  BRA    0874
0878:  MOVLW  00
087A:  BTFSC  FC5.6
087C:  MOVLW  01
087E:  MOVWF  01
0880:  RETURN 0
*
0A0A:  BCF    FC6.6
0A0C:  BSF    FC5.3
0A0E:  BTFSC  FC5.3
0A10:  BRA    0A0E
0A12:  BTFSC  00.0
0A14:  BCF    FC5.5
0A16:  BTFSS  00.0
0A18:  BSF    FC5.5
0A1A:  BSF    FC5.4
0A1C:  BTFSC  FC5.4
0A1E:  BRA    0A1C
0A20:  MOVFF  FC9,01
0A24:  RETURN 0
.................... #use rs232(baud=38400, xmit=PIN_C6, rcv=PIN_C7) 
.................... #include <can-18xxx8.c> 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////                        can-18xxx8.c                             //// 
.................... //// CAN Library routines for Microchip's PIC18Cxx8 and 18Fxx8 line  //// 
.................... ////                                                                 //// 
.................... //// This library provides the following functions:                  //// 
.................... ////  (for more information on these functions see the comment       //// 
.................... ////   header above each function)                                   //// 
.................... ////                                                                 //// 
.................... ////    can_init - Configures the PIC18xxx8 CAN peripheral           //// 
.................... ////                                                                 //// 
.................... ////    can_set_baud - Sets the baud rate control registers          //// 
.................... ////                                                                 //// 
.................... ////    can_set_mode - Sets the CAN module into a specific mode      //// 
.................... ////                                                                 //// 
.................... ////    can_set_id - Sets the standard and extended ID               //// 
.................... ////                                                                 //// 
.................... ////    can_get_id - Gets the standard and extended ID               //// 
.................... ////                                                                 //// 
.................... ////    can_putd - Sends a message/request with specified ID         //// 
.................... ////                                                                 //// 
.................... ////    can_getd - Returns specified message/request and ID           //// 
.................... ////                                                                 //// 
.................... ////    can_kbhit - Returns true if there is data in one of the      //// 
.................... ////                receive buffers                                  //// 
.................... ////                                                                 //// 
.................... ////    can_tbe - Returns true if the transmit buffer is ready to    //// 
.................... ////              send more data                                     //// 
.................... ////                                                                 //// 
.................... ////    can_abort - Aborts all pending transmissions                 //// 
.................... ////                                                                 //// 
.................... //// PIN_B3 is CANRX, and PIN_B2 is CANTX.  You will need a CAN      //// 
.................... //// transceiver to connect these pins to CANH and CANL bus lines.    //// 
.................... ////                                                                 //// 
.................... //// CCS provides an example, ex_can.c, which shows how to use this  //// 
.................... //// library.                                                        //// 
.................... ////                                                                 //// 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////                                                                 //// 
.................... //// Version History                                                 //// 
.................... ////                                                                 //// 
.................... ////  Jul 27 04 - can_init() uses CAN_USE_EXTENDED_ID instead of     //// 
.................... ////              setting all RX filters to extended.                //// 
.................... ////                                                                 //// 
.................... ////  Feb 24 04 - can_get_id() fixed for EID<18:20>.                 //// 
.................... ////                                                                 //// 
.................... ////  Mar 30 09 - added CANTX2 code for PIC18F6585/8585/6680/8680    //// 
.................... ////                                                                 //// 
.................... ////  May 18 10 - changed variable types to unsigned incase compiled //// 
.................... ////              with #device ANSI, which makes variables signed    //// 
.................... ////                                                                 //// 
.................... ////  Apr 20 11 - updated for new PIC18FxxK80 chips                  //// 
.................... ////                                                                 //// 
.................... ////  Jan 10 13 - updated can_init() function to setup correct tris  //// 
.................... ////              register for PIC being used.                       //// 
.................... ////                                                                 //// 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2013 Custom Computer Services         //// 
.................... //// This source code may only be used by licensed users of the CCS  //// 
.................... //// C compiler.  This source code may only be distributed to other  //// 
.................... //// licensed users of the CCS C compiler.  No other use,            //// 
.................... //// reproduction or distribution is permitted without written       //// 
.................... //// permission.  Derivative programs created using this software    //// 
.................... //// in object code form are not restricted in any way.              //// 
.................... ///////////////////////////////////////////////////////////////////////// 
....................  
.................... #include <can-18xxx8.h> 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////                        can-18xxx8.h                             //// 
.................... ////                                                                 //// 
.................... //// Prototypes, definitions, defines and macros used for and with   //// 
.................... //// the CCS CAN library for PIC18Fxx8 and PIC18Cxx8.                //// 
.................... ////                                                                 //// 
.................... //// (see can-18xxx8.c)                                              //// 
.................... ////                                                                 //// 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2013 Custom Computer Services         //// 
.................... //// This source code may only be used by licensed users of the CCS  //// 
.................... //// C compiler.  This source code may only be distributed to other  //// 
.................... //// licensed users of the CCS C compiler.  No other use,            //// 
.................... //// reproduction or distribution is permitted without written       //// 
.................... //// permission.  Derivative programs created using this software    //// 
.................... //// in object code form are not restricted in any way.              //// 
.................... ///////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef __CCS_CAN18xxx8_LIB_DEFINES__ 
.................... #define __CCS_CAN18xxx8_LIB_DEFINES__ 
....................  
.................... #ifndef CAN_DO_DEBUG 
....................  #define CAN_DO_DEBUG FALSE 
.................... #endif 
....................  
.................... #IFNDEF CAN_USE_EXTENDED_ID 
....................   #define CAN_USE_EXTENDED_ID         TRUE 
.................... #ENDIF 
....................  
.................... #IFNDEF CAN_BRG_SYNCH_JUMP_WIDTH 
....................   #define CAN_BRG_SYNCH_JUMP_WIDTH  0  //synchronized jump width (def: 1 x Tq) 
.................... #ENDIF 
....................  
.................... #IFNDEF CAN_BRG_PRESCALAR 
....................   #define CAN_BRG_PRESCALAR  4  //baud rate generator prescalar (def: 4) ( Tq = (2 x (PRE + 1))/Fosc ) 
.................... #ENDIF 
....................  
.................... #ifndef CAN_BRG_SEG_2_PHASE_TS 
....................  #define CAN_BRG_SEG_2_PHASE_TS   TRUE //phase segment 2 time select bit (def: freely programmable) 
.................... #endif 
....................  
.................... #ifndef CAN_BRG_SAM 
....................  #define CAN_BRG_SAM 0 //sample of the can bus line (def: bus line is sampled 1 times prior to sample point) 
.................... #endif 
....................  
.................... #ifndef CAN_BRG_PHASE_SEGMENT_1 
....................  #define CAN_BRG_PHASE_SEGMENT_1  5 //phase segment 1 (def: 6 x Tq) 
.................... #endif 
....................  
.................... #ifndef CAN_BRG_PROPAGATION_TIME 
....................  #define CAN_BRG_PROPAGATION_TIME 2 //propagation time select (def: 3 x Tq) 
.................... #endif 
....................  
.................... #ifndef CAN_BRG_WAKE_FILTER 
....................  #define CAN_BRG_WAKE_FILTER FALSE   //selects can bus line filter for wake up bit 
.................... #endif 
....................  
.................... #ifndef CAN_BRG_PHASE_SEGMENT_2 
....................  #define CAN_BRG_PHASE_SEGMENT_2 5 //phase segment 2 time select (def: 6 x Tq) 
.................... #endif 
....................  
.................... #ifndef CAN_USE_RX_DOUBLE_BUFFER 
....................  #define CAN_USE_RX_DOUBLE_BUFFER TRUE   //if buffer 0 overflows, do NOT use buffer 1 to put buffer 0 data 
.................... #endif 
....................  
.................... #ifndef CAN_ENABLE_DRIVE_HIGH 
....................  #define CAN_ENABLE_DRIVE_HIGH 0 
.................... #endif 
....................  
.................... #ifndef CAN_ENABLE_CAN_CAPTURE 
....................  #define CAN_ENABLE_CAN_CAPTURE 0 
.................... #endif 
....................  
.................... #ifndef CAN_ENABLE_CANTX2           // added 03/30/09 for PIC18F6585/8585/6680/8680 
....................    #define CAN_ENABLE_CANTX2 0      // 0 CANTX2 disabled, 1 CANTX2 enabled 
.................... #endif 
....................  
.................... #ifndef CAN_CANTX2_SOURCE           // added 03/30/09 for PIC18F6585/8585/6680/8680 
....................    #define CAN_CANTX2_SOURCE 0      // 0 source is invert of CANTX1, 1 source is CAN Clock 
.................... #endif 
....................  
.................... enum CAN_OP_MODE {CAN_OP_CONFIG=4, CAN_OP_LISTEN=3, CAN_OP_LOOPBACK=2, CAN_OP_DISABLE=1, CAN_OP_NORMAL=0}; 
.................... enum CAN_WIN_ADDRESS {CAN_WIN_RX0=0, CAN_WIN_RX1=5, CAN_WIN_TX0=4, CAN_WIN_TX1=3, CAN_WIN_TX2=2}; 
....................  
.................... //can control 
.................... struct { 
....................    int1 void0; //0 
....................    CAN_WIN_ADDRESS win:3;   //1:3 //window address bits 
....................    int1 abat;   //4 //abort all pending transmissions 
....................    CAN_OP_MODE reqop:3;   //5:7   //request can operation mode bits 
.................... } CANCON; 
.................... #byte CANCON = getenv("SFR:CANCON")   //0xF6F 
....................  
....................  
.................... enum CAN_INT_CODE {CAN_INT_WAKEUP=7, CAN_INT_RX0=6, CAN_INT_RX1=5, CAN_INT_TX0=4, CAN_INT_TX1=3, CAN_INT_TX2=2, CAN_INT_ERROR=1, CAN_INT_NO=0}; 
....................  
.................... //can status register READ-ONLY 
.................... struct { 
....................    int1 void0;   //0 
....................    CAN_INT_CODE icode:3;   //1:3   //interrupt code 
....................    int1 void4;   //4 
....................    CAN_OP_MODE opmode:3;   //5:7   //operation mode status 
.................... } CANSTAT; 
.................... #byte CANSTAT = getenv("SFR:CANSTAT")   //0xF6E 
....................  
.................... //communication status register READ-ONLY 
.................... struct { 
....................    int1 ewarn;      //0 //error warning 
....................    int1 rxwarn;      //1 //receiver warning 
....................    int1 txwarn;      //2 //transmitter warning 
....................    int1 rxbp;   //3 //receiver bus passive 
....................    int1 txbp;   //4 //transmitter bus passive bit 
....................    int1 txbo;   //5   //transmitter bus off 
....................    int1 rx1ovfl;   //6   //receive buffer 1 overflow 
....................    int1 rx0ovfl;   //7   //receive buffer 0 overflow 
.................... } COMSTAT; 
.................... #byte COMSTAT= getenv("SFR:COMSTAT") //0xF74 
....................  
.................... //baud rate control register 1 
.................... struct { 
....................    int brp:6;   //0:5   //baud rate prescalar 
....................    int sjw:2;   //6:7   //synchronized jump width 
.................... } BRGCON1; 
.................... #byte BRGCON1 = getenv("SFR:BRGCON1")   //0xF70 
....................  
.................... //baud rate control register 2 
.................... struct { 
....................    int prseg:3; //0:2 //propagation time select 
....................    int seg1ph:3; //3:5 //phase segment 1 
....................    int1 sam; //6 //sample of the can bus line 
....................    int1 seg2phts; //7 //phase segment 2 time select 
.................... } BRGCON2; 
.................... #byte BRGCON2 = getenv("SFR:BRGCON2")   //0xF71 
....................  
.................... //baud rate control register 3 
.................... struct { 
....................    int seg2ph:3;   //0:2   //phase segment 2 time select 
....................    int void543:3;   //3:5 
....................    int1 wakfil;   //6 //selects can bus line filter for wake-up 
....................    int1 void7;   //7 
.................... } BRGCON3; 
.................... #byte BRGCON3 = getenv("SFR:BRGCON3")   //0xF72 
....................  
.................... //can i/o control register 
.................... struct { 
....................    int void3210:4;   //0:3 
....................    int1 cancap;   //4 //can message receive capture 
....................    int1 endrhi;   //5 //enable drive high 
....................    int1 tx2en;    //6   //CANTX2 Pin Enable bit       //added 3/30/09 for PIC18F6585/8585/6680/8680 
....................    int1 tx2src;   //7   //CANTX2 Pin Data Source bit  //added 3/30/09 for PIC18F6585/8585/6680/8680 
.................... } CIOCON; 
.................... #byte CIOCON = getenv("SFR:CIOCON")    //0xF73 
....................  
.................... //transmit buffer n control register 
.................... struct txbNcon_struct { 
....................    int  txpri:2;   //0:1   //transmit priority bits 
....................    int1 void2; //2 
....................    int1 txreq;   //3   //transmit request status (clear to request message abort) 
....................    int1 txerr;   //4   //transmission error detected 
....................    int1 txlarb;   //5   //transmission lost arbitration status 
....................    int1 txabt;   //6   //transmission aborted status 
....................    int1 void7; 
.................... }; 
.................... struct txbNcon_struct TXB0CON; 
.................... struct txbNcon_struct TXB1CON; 
.................... struct txbNcon_struct TXB2CON; 
.................... struct txbNcon_struct TXBaCON; 
.................... #byte   TXB0CON = getenv("SFR:TXB0CON")      //0xF40 
.................... #byte   TXB1CON = getenv("SFR:TXB1CON")      //0xF30 
.................... #byte   TXB2CON = getenv("SFR:TXB2CON")      //0xF20 
.................... #byte TXBaCON =     0xF60             // txbXcon when in the access bank 
....................  
....................  
.................... //transmit buffer n standard identifier 
.................... #byte TXB0SIDH = getenv("SFR:TXB0SIDH")      // 
.................... #byte TXB0SIDL = getenv("SFR:TXB0SIDL")      // 
.................... #byte TXB1SIDH = getenv("SFR:TXB1SIDH")      // 
.................... #byte TXB1SIDL = getenv("SFR:TXB1SIDL")      // 
.................... #byte TXB2SIDH = getenv("SFR:TXB2SIDH")      // 
.................... #byte TXB2SIDL = getenv("SFR:TXB2SIDL")      // 
....................  
.................... //transmit buffer n extended identifier 
.................... #byte TXB0EIDH = getenv("SFR:TXB0EIDH")      //0xF43 
.................... #byte TXB0EIDL = getenv("SFR:TXB0EIDL")      //0xF44 
.................... #byte TXB1EIDH = getenv("SFR:TXB1EIDH")      //0xF33 
.................... #byte TXB1EIDL = getenv("SFR:TXB1EIDL")      //0xF34 
.................... #byte TXB2EIDH = getenv("SFR:TXB2EIDH")      //0xF23 
.................... #byte TXB2EIDL = getenv("SFR:TXB2EIDL")      //0xF24 
....................  
.................... #define RX0MASK      getenv("SFR:RXM0EIDL")     //0xF1B    //rxm0eidl 
.................... #define RX1MASK      getenv("SFR:RXM1EIDL")     //0xF1F    //rxm1eidl 
.................... #define RX0FILTER0   getenv("SFR:RXF0EIDL")     //0xF03    //rxf0eidl 
.................... #define RX0FILTER1   getenv("SFR:RXF1EIDL")     //0xF07    //rxf1eidl 
.................... #define RX1FILTER2   getenv("SFR:RXF2EIDL")     //0xF0B    //rxf2eidl 
.................... #define RX1FILTER3   getenv("SFR:RXF3EIDL")     //0xF0F    //rxf3eidl 
.................... #define RX1FILTER4   getenv("SFR:RXF4EIDL")     //0xF13    //rxf4eidl 
.................... #define RX1FILTER5   getenv("SFR:RXF5EIDL")     //0xF17    //rxf5eidl 
.................... #define RXB0ID       getenv("SFR:RXB0EIDL")     //0xF64    //rxb0eidl 
.................... #define RXB1ID       getenv("SFR:RXB1EIDL")     //0xF54    //rxb1eidl 
.................... #define TXB0ID       getenv("SFR:TXB0EIDL")     //0xF44    //txb0eidl 
.................... #define TXB1ID       getenv("SFR:TXB1EIDL")     //0xF34    //txb1eidl 
.................... #define TXB2ID       getenv("SFR:TXB2EIDL")     //0xF24    //tsb2eidl 
.................... #define TXRXBaID     0xF64 
....................  
.................... //transmit buffer n data byte m 
.................... #byte TXB0D0 = getenv("SFR:TXB0D0")       //0xF46 
.................... #byte TXB0D7 = getenv("SFR:TXB0D7")       //0xF4D 
.................... #byte TXB1D0 = getenv("SFR:TXB1D0")       //0xF36 
.................... #byte TXB1D7 = getenv("SFR:TXB1D7")       //0xF3D 
.................... #byte TXB2D0 = getenv("SFR:TXB2D0")       //0xF26 
.................... #byte TXB2D7 = getenv("SFR:TXB2D7")       //0xF2D 
....................  
.................... //transmit buffer n data length 
.................... struct txbNdlc_struct { 
....................    int dlc:4;   //0:3 
....................    int void54:2; //4:5 
....................    int1 rtr; //6 //transmission frame remote transmission 
....................    int1 void7; //7 
.................... }; 
.................... struct txbNdlc_struct TXB0DLC; 
.................... struct txbNdlc_struct TXB1DLC; 
.................... struct txbNdlc_struct TXB2DLC; 
.................... struct txbNdlc_struct TXBaDLC; 
.................... #byte TXB0DLC = getenv("SFR:TXB0DLC")     //0xF45 
.................... #byte TXB1DLC = getenv("SFR:TXB1DLC")     //0xF35 
.................... #byte TXB2DLC = getenv("SFR:TXB2DLC")     //0xF25 
.................... #byte TXBaDLC = 0xF65  //txbXdlc when in the access bank 
....................  
....................  
.................... //transmit error count register 
.................... #byte TXERRCNT=getenv("SFR:TXERRCNT")     //0xF76 
....................  
....................  
.................... enum CAN_RX_MODE {CAN_RX_ALL=3, CAN_RX_EXT=2, CAN_RX_STD=1, CAN_RX_VALID=0}; 
....................  
.................... //receive buffer 0 control register 
.................... struct { 
....................    int1 filthit0;   //0 //filter hit 
....................    int1 jtoff;   //1 //jump table offset 
....................    int1 rxb0dben;   //2 //receive buffer 0 double buffer enable 
....................    int1 rxrtrro;   //3 //receive remote transfer request 
....................    int1 void4;   //4 
....................    CAN_RX_MODE rxm:2;   //5:6 //receiver buffer mode 
....................    int1 rxful;   //7 //receive full status 
.................... } RXB0CON; 
.................... #byte RXB0CON = getenv("SFR:RXB0CON")     //0xF60 
....................  
.................... //receive buffer 1 control register 
.................... struct { 
....................    int filthit:3;   //0:2 
....................    int1 rxrtrro;   //3 //receive remote transfer request 
....................    int1 void4;   //4 
....................    CAN_RX_MODE rxm:2;   //5:6 //receive buffer mode 
....................    int1 rxful;   //7   //receive full 
.................... } RXB1CON; 
.................... #byte   RXB1CON = getenv("SFR:RXB1CON")     //0xF50 
....................  
....................  
.................... //receive buffer n standard identifier 
.................... #byte   RXB0SIDH = getenv("SFR:RXB0SIDH")    //0xF61 
.................... #byte   RXB0SIDL = getenv("SFR:RXB0SIDL")    //0xF62 
.................... #byte   RXB1SIDH = getenv("SFR:RXB1SIDH")    //0xF51 
.................... #byte   RXB1SIDL = getenv("SFR:RXB1SIDL")    //0xF52 
....................  
.................... //receive buffer n extended identifier 
.................... #byte   RXB0EIDH = getenv("SFR:RXB0EIDH")    //0xF63 
.................... #byte   RXB0EIDL = getenv("SFR:RXB0EIDL")    //0xF64 
.................... #byte   RXB1EIDH = getenv("SFR:RXB1EIDH")    //0xF53 
.................... #byte   RXB1EIDL = getenv("SFR:RXB1EIDL")    //0xF54 
....................  
.................... #byte TXRXBaEIDL=0xF64 
....................  
.................... struct { 
....................    int void012:3; //0:3 
....................    int1 ext;   //extended id 
....................    int1 srr;   //substitute remove request bit 
....................    int void567:3; //5:7 
.................... } TXRXBaSIDL; 
.................... #byte TXRXBaSIDL=0xF62 
....................  
.................... //receive buffer n data length code register 
.................... struct rxbNdlc_struct { 
....................    int dlc:4;   //0:3 //data length code 
....................    int1 rb0; //4 //reserved 
....................    int1 rb1;   //5 //reserved 
....................    int1 rtr;   //6 //receiver remote transmission request bit 
....................    int1 void7;   //7 
.................... }; 
.................... struct rxbNdlc_struct RXB0DLC; 
.................... struct rxbNdlc_struct RXB1DLC; 
.................... struct rxbNdlc_struct RXBaDLC; 
.................... #byte   RXB0DLC = getenv("SFR:RXB0DLC")      //0xF65 
.................... #byte   RXB1DLC = getenv("SFR:RXB1DLC")      //0xF55 
.................... #byte   RXBaDLC = getenv("SFR:RXB0DLC")      //0xF65 
.................... //receive buffer n data field byte m register 
.................... #byte RXB0D0 = getenv("SFR:RXB0D0")    //0xF66 
.................... #byte RXB0D7 = getenv("SFR:RXB0D7")    //0xF6D 
.................... #byte TXRXBaD0=0xF66 
.................... #byte TXRXBaD7=0xF6D 
....................  
.................... //receive error count 
.................... #byte RXERRCNT = getenv("SFR:RXERRCNT")      //0xF75 
....................  
.................... //receive acceptance filter n standard identifier 
.................... #byte RXF0SIDH = getenv("SFR:RXF0SIDH")      //0xF00 
.................... #byte RXF0SIDL = getenv("SFR:RXF0SIDL")      //0xF01 
.................... #byte RXF1SIDH = getenv("SFR:RXF1SIDH")      //0xF04 
.................... #byte RXF1SIDL = getenv("SFR:RXF1SIDL")      //0xF05 
.................... #byte RXF2SIDH = getenv("SFR:RXF2SIDH")      //0xF08 
.................... #byte RXF2SIDL = getenv("SFR:RXF2SIDL")      //0xF09 
.................... #byte RXF3SIDH = getenv("SFR:RXF3SIDH")      //0xF0C 
.................... #byte RXF3SIDL = getenv("SFR:RXF3SIDL")      //0xF0D 
.................... #byte RXF4SIDH = getenv("SFR:RXF4SIDH")      //0xF10 
.................... #byte RXF4SIDL = getenv("SFR:RXF4SIDL")      //0xF11 
.................... #byte RXF5SIDH = getenv("SFR:RXF5SIDH")      //0xF14 
.................... #byte RXF5SIDL = getenv("SFR:RXF5SIDL")      //0xF15 
....................  
.................... //receive acceptance filter n extended identifier 
.................... #byte RXF0EIDH = getenv("SFR:RXF0EIDH")      //0xF02 
.................... #byte RXF0EIDL = getenv("SFR:RXF0EIDL")      //0xF03 
.................... #byte RXF1EIDH = getenv("SFR:RXF1EIDH")      //0xF06 
.................... #byte RXF1EIDL = getenv("SFR:RXF1EIDL")      //0xF07 
.................... #byte RXF2EIDH = getenv("SFR:RXF2EIDH")      //0xF0A 
.................... #byte RXF2EIDL = getenv("SFR:RXF2EIDL")      //0xF0B 
.................... #byte RXF3EIDH = getenv("SFR:RXF3EIDH")      //0xF0E 
.................... #byte RXF3EIDL = getenv("SFR:RXF3EIDL")      //0xF0F 
.................... #byte RXF4EIDH = getenv("SFR:RXF4EIDH")      //0xF12 
.................... #byte RXF4EIDL = getenv("SFR:RXF4EIDL")      //0xF13 
.................... #byte RXF5EIDH = getenv("SFR:RXF5EIDH")      //0xF16 
.................... #byte RXF5EIDL = getenv("SFR:RXF5EIDL")      //0xF17 
....................  
.................... //receive acceptance mask n standard identifier mask 
.................... #byte RXM0SIDH = getenv("SFR:RXM0SIDH")      //0xF18 
.................... #byte RXM0SIDL = getenv("SFR:RXM0SIDL")      //0xF19 
.................... #byte RXM1SIDH = getenv("SFR:RXM1SIDH")      //0xF1C 
.................... #byte RXM1SIDL = getenv("SFR:RXM1SIDL")      //0xF1D 
....................  
.................... //receive acceptance mask n extended identifier mask 
.................... #byte RXM0EIDH = getenv("SFR:RXM0EIDH")      //0xF1A 
.................... #byte RXM0EIDL = getenv("SFR:RXM0EIDL")      //0xF1B 
.................... #byte RXM1EIDH = getenv("SFR:RXM1EIDH")      //0xF1E 
.................... #byte RXM1EIDL = getenv("SFR:RXM1EIDL")      //0xF1F 
....................  
.................... //value to put in mask field to accept all incoming id's 
.................... #define CAN_MASK_ACCEPT_ALL   0 
....................  
.................... //can interrupt flags 
.................... #bit CAN_INT_IRXIF = getenv("BIT:IRXIF")     //0xFA4.7 
.................... #bit CAN_INT_WAKIF = getenv("BIT:WAKIF")     //0xFA4.6 
.................... #bit CAN_INT_ERRIF = getenv("BIT:ERRIF")     //0xFA4.5 
.................... #bit CAN_INT_TXB2IF = getenv("BIT:TXB2IF")   // 0xFA4.4 
.................... #bit CAN_INT_TXB1IF = getenv("BIT:TXB1IF")   // 0xFA4.3 
.................... #bit CAN_INT_TXB0IF = getenv("BIT:TXB0IF")   // 0xFA4.2 
.................... #bit CAN_INT_RXB1IF = getenv("BIT:RXB1IF")   // 0xFA4.1 
.................... #bit CAN_INT_RXB0IF = getenv("BIT:RXB0IF")   // 0xFA4.0 
....................  
.................... //PROTOTYPES 
....................  
.................... struct rx_stat { 
....................    int1 err_ovfl; 
....................    int filthit:3; 
....................    int1 buffer; 
....................    int1 rtr; 
....................    int1 ext; 
....................    int1 inv; 
.................... }; 
....................  
.................... void  can_init(void); 
.................... void  can_set_baud(void); 
.................... void  can_set_mode(CAN_OP_MODE mode); 
.................... void  can_set_id(unsigned int* addr, unsigned int32 id, int1 ext); 
.................... unsigned int32 can_get_id(unsigned int * addr, int1 ext); 
.................... int1  can_putd(unsigned int32 id, unsigned int * data, unsigned int len, unsigned int priority, int1 ext, int1 rtr); 
.................... int1  can_getd(unsigned int32 & id, unsigned int * data, unsigned int & len, struct rx_stat & stat); 
....................  
.................... #endif 
....................  
....................  
.................... #if CAN_DO_DEBUG 
....................  #define can_debug printf 
.................... #else 
....................  #define can_debug 
.................... #endif 
....................  
....................  
.................... //macros 
.................... #define can_kbhit()                 (RXB0CON.rxful || RXB1CON.rxful) 
.................... #define can_tbe()                   (!TXB0CON.txreq || !TXB1CON.txreq || !TXB2CON.txreq) 
.................... #define can_abort()                 (CANCON.abat=1) 
....................  
....................  
.................... //////////////////////////////////////////////////////////////////////// 
.................... // 
.................... // can_init() 
.................... // 
.................... // Initializes PIC18xxx8 CAN peripheral.  Sets the RX filter and masks so the 
.................... // CAN peripheral will receive all incoming IDs.  Configures both RX buffers 
.................... // to only accept valid messages (as opposed to all messages, or all 
.................... // extended message, or all standard messages).  Also sets the tri-state 
.................... // setting of B2 to output, and B3 to input (apparently the CAN peripheral 
.................... // doesn't keep track of this) 
.................... // 
.................... // The constants (CAN_USE_RX_DOUBLE_BUFFER, CAN_ENABLE_DRIVE_HIGH, 
.................... // CAN_ENABLE_CAN_CAPTURE) are given a default define in the can-18xxx8.h file. 
.................... // These default values can be overwritten in the main code, but most 
.................... // applications will be fine with these defaults. 
.................... // 
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... void can_init(void) { 
....................    can_set_mode(CAN_OP_CONFIG);   //must be in config mode before params can be set 
*
078A:  MOVLW  04
078C:  MOVWF  41
078E:  RCALL  0608
....................    can_set_baud(); 
0790:  BRA    062A
....................  
....................    RXB0CON=0; 
0792:  CLRF   F60
....................    RXB0CON.rxm=CAN_RX_VALID; 
0794:  MOVLW  9F
0796:  ANDWF  F60,W
0798:  MOVWF  F60
....................    RXB0CON.rxb0dben=CAN_USE_RX_DOUBLE_BUFFER; 
079A:  BSF    F60.2
....................    RXB1CON=RXB0CON; 
079C:  MOVFF  F60,F50
....................  
....................    CIOCON.endrhi=CAN_ENABLE_DRIVE_HIGH; 
07A0:  BCF    F73.5
....................    CIOCON.cancap=CAN_ENABLE_CAN_CAPTURE; 
07A2:  BCF    F73.4
....................    CIOCON.tx2src=CAN_CANTX2_SOURCE;       //added 3/30/09 for PIC18F6585/8585/6680/8680 
07A4:  BCF    F73.7
....................    CIOCON.tx2en=CAN_ENABLE_CANTX2;        //added 3/30/09 for PIC18F6585/8585/6680/8680 
07A6:  BCF    F73.6
....................  
....................    can_set_id(RX0MASK, CAN_MASK_ACCEPT_ALL, CAN_USE_EXTENDED_ID);  //set mask 0 
07A8:  MOVLW  0F
07AA:  MOVWF  52
07AC:  MOVLW  1B
07AE:  MOVWF  51
07B0:  CLRF   56
07B2:  CLRF   55
07B4:  CLRF   54
07B6:  CLRF   53
07B8:  MOVLW  01
07BA:  MOVWF  57
07BC:  RCALL  065A
....................    can_set_id(RX0FILTER0, 0, CAN_USE_EXTENDED_ID);  //set filter 0 of mask 0 
07BE:  MOVLW  0F
07C0:  MOVWF  52
07C2:  MOVLW  03
07C4:  MOVWF  51
07C6:  CLRF   56
07C8:  CLRF   55
07CA:  CLRF   54
07CC:  CLRF   53
07CE:  MOVLW  01
07D0:  MOVWF  57
07D2:  RCALL  065A
....................    can_set_id(RX0FILTER1, 0, CAN_USE_EXTENDED_ID);  //set filter 1 of mask 0 
07D4:  MOVLW  0F
07D6:  MOVWF  52
07D8:  MOVLW  07
07DA:  MOVWF  51
07DC:  CLRF   56
07DE:  CLRF   55
07E0:  CLRF   54
07E2:  CLRF   53
07E4:  MOVLW  01
07E6:  MOVWF  57
07E8:  RCALL  065A
....................  
....................    can_set_id(RX1MASK, CAN_MASK_ACCEPT_ALL, CAN_USE_EXTENDED_ID);  //set mask 1 
07EA:  MOVLW  0F
07EC:  MOVWF  52
07EE:  MOVLW  1F
07F0:  MOVWF  51
07F2:  CLRF   56
07F4:  CLRF   55
07F6:  CLRF   54
07F8:  CLRF   53
07FA:  MOVLW  01
07FC:  MOVWF  57
07FE:  RCALL  065A
....................    can_set_id(RX1FILTER2, 0, CAN_USE_EXTENDED_ID);  //set filter 0 of mask 1 
0800:  MOVLW  0F
0802:  MOVWF  52
0804:  MOVLW  0B
0806:  MOVWF  51
0808:  CLRF   56
080A:  CLRF   55
080C:  CLRF   54
080E:  CLRF   53
0810:  MOVLW  01
0812:  MOVWF  57
0814:  RCALL  065A
....................    can_set_id(RX1FILTER3, 0, CAN_USE_EXTENDED_ID);  //set filter 1 of mask 1 
0816:  MOVLW  0F
0818:  MOVWF  52
081A:  MOVWF  51
081C:  CLRF   56
081E:  CLRF   55
0820:  CLRF   54
0822:  CLRF   53
0824:  MOVLW  01
0826:  MOVWF  57
0828:  RCALL  065A
....................    can_set_id(RX1FILTER4, 0, CAN_USE_EXTENDED_ID);  //set filter 2 of mask 1 
082A:  MOVLW  0F
082C:  MOVWF  52
082E:  MOVLW  13
0830:  MOVWF  51
0832:  CLRF   56
0834:  CLRF   55
0836:  CLRF   54
0838:  CLRF   53
083A:  MOVLW  01
083C:  MOVWF  57
083E:  RCALL  065A
....................    can_set_id(RX1FILTER5, 0, CAN_USE_EXTENDED_ID);  //set filter 3 of mask 1 
0840:  MOVLW  0F
0842:  MOVWF  52
0844:  MOVLW  17
0846:  MOVWF  51
0848:  CLRF   56
084A:  CLRF   55
084C:  CLRF   54
084E:  CLRF   53
0850:  MOVLW  01
0852:  MOVWF  57
0854:  RCALL  065A
....................  
....................   #if (getenv("DEVICE") == "PIC18F6585") || (getenv("DEVICE") == "PIC18LF6585") || \ 
....................       (getenv("DEVICE") == "PIC18F6680") || (getenv("DEVICE") == "PIC18LF6680") || \ 
....................       (getenv("DEVICE") == "PIC18F8585") || (getenv("DEVICE") == "PIC18LF8585") || \ 
....................       (getenv("DEVICE") == "PIC18F8680") || (getenv("DEVICE") == "PIC18LF8680") || \ 
....................       (getenv("DEVICE") == "PIC18C658") || (getenv("DEVICE") == "PIC18C858") 
....................    set_tris_g((*getenv("SFR:TRISG") & 0xFE) | 0x04);  //G2 in, G0 out 
....................    if(CAN_ENABLE_CANTX2) 
....................     bit_clear(*getenv("SFR:TRISG"), 1);  //G1 out 
....................   #elif getenv("FUSE_SET:CANE") 
....................    set_tris_e((*getenv("SFR:TRISE") & 0xDF) | 0x10);  //E4 in, E5 out 
....................   #elif getenv("FUSE_SET:CANC") 
....................    set_tris_c((*getenv("SFR:TRISC") & 0xBF) | 0x80);  //C7 in, C6 out 
....................   #else 
....................    set_tris_b((*getenv("SFR:TRISB") & 0xFB) | 0x08);  //B3 in, B2 out 
0856:  MOVF   F93,W
0858:  ANDLW  FB
085A:  IORLW  08
085C:  MOVWF  F93
....................   #endif 
....................  
....................    can_set_mode(CAN_OP_NORMAL); 
085E:  CLRF   41
0860:  RCALL  0608
0862:  GOTO   1600 (RETURN)
.................... } 
....................  
.................... //////////////////////////////////////////////////////////////////////// 
.................... // 
.................... // can_set_baud() 
.................... // 
.................... // Configures the baud rate control registers.  All the defines here 
.................... // are defaulted in the can-18xxx8.h file.  These defaults can, and 
.................... // probably should, be overwritten in the main code. 
.................... // 
.................... // Current defaults are set to work with Microchip's MCP250xxx CAN 
.................... // Developers Kit if this PIC is running at 20Mhz. 
.................... // 
.................... //////////////////////////////////////////////////////////////////////// 
.................... void can_set_baud(void) { 
....................    BRGCON1.brp=CAN_BRG_PRESCALAR; 
*
062A:  MOVLW  C0
062C:  ANDWF  F70,W
062E:  IORLW  04
0630:  MOVWF  F70
....................    BRGCON1.sjw=CAN_BRG_SYNCH_JUMP_WIDTH; 
0632:  MOVLW  3F
0634:  ANDWF  F70,W
0636:  MOVWF  F70
....................  
....................    BRGCON2.prseg=CAN_BRG_PROPAGATION_TIME; 
0638:  MOVLW  F8
063A:  ANDWF  F71,W
063C:  IORLW  02
063E:  MOVWF  F71
....................    BRGCON2.seg1ph=CAN_BRG_PHASE_SEGMENT_1; 
0640:  MOVLW  C7
0642:  ANDWF  F71,W
0644:  IORLW  28
0646:  MOVWF  F71
....................    BRGCON2.sam=CAN_BRG_SAM; 
0648:  BCF    F71.6
....................    BRGCON2.seg2phts=CAN_BRG_SEG_2_PHASE_TS; 
064A:  BSF    F71.7
....................  
....................    BRGCON3.seg2ph=CAN_BRG_PHASE_SEGMENT_2; 
064C:  MOVLW  F8
064E:  ANDWF  F72,W
0650:  IORLW  05
0652:  MOVWF  F72
....................    BRGCON3.wakfil=CAN_BRG_WAKE_FILTER; 
0654:  BCF    F72.6
0656:  GOTO   0792 (RETURN)
.................... } 
....................  
.................... void can_set_mode(CAN_OP_MODE mode) { 
....................    CANCON.reqop=mode; 
*
0608:  SWAPF  41,W
060A:  ANDLW  70
060C:  MOVWF  00
060E:  BCF    FD8.0
0610:  RLCF   00,F
0612:  MOVLW  1F
0614:  ANDWF  F6F,W
0616:  IORWF  00,W
0618:  MOVWF  F6F
....................    while( (CANSTAT.opmode) != mode ); 
061A:  MOVFF  F6E,00
061E:  SWAPF  00,F
0620:  RRCF   00,W
0622:  ANDLW  07
0624:  SUBWF  41,W
0626:  BNZ   061A
0628:  RETURN 0
.................... } 
....................  
....................  
.................... //////////////////////////////////////////////////////////////////////// 
.................... // 
.................... // can_set_id() 
.................... // 
.................... // Configures the xxxxEIDL, xxxxEIDH, xxxxSIDL and xxxxSIDH registers to 
.................... // configure the defined buffer to use the specified ID 
.................... // 
.................... //   Parameters: 
.................... //     addr - pointer to first byte of ID register, starting with xxxxEIDL. 
.................... //            For example, a pointer to RXM1EIDL 
.................... //     id - ID to set buffer to 
.................... //     ext - Set to TRUE if this buffer uses an extended ID, FALSE if not 
.................... // 
.................... //////////////////////////////////////////////////////////////////////// 
.................... void can_set_id(unsigned int* addr, unsigned int32 id, int1 ext) { 
....................    int *ptr; 
....................  
....................    ptr=addr; 
*
065A:  MOVFF  52,59
065E:  MOVFF  51,58
....................  
....................    if (ext) {  //extended 
0662:  MOVF   57,F
0664:  BZ    070A
....................       //eidl 
....................       *ptr=make8(id,0); //0:7 
0666:  MOVFF  58,FE9
066A:  MOVFF  59,FEA
066E:  MOVFF  53,FEF
....................  
....................       //eidh 
....................       ptr--; 
0672:  MOVF   58,W
0674:  BTFSC  FD8.2
0676:  DECF   59,F
0678:  DECF   58,F
....................       *ptr=make8(id,1); //8:15 
067A:  MOVFF  58,FE9
067E:  MOVFF  59,FEA
0682:  MOVFF  54,FEF
....................  
....................       //sidl 
....................       ptr--; 
0686:  MOVF   58,W
0688:  BTFSC  FD8.2
068A:  DECF   59,F
068C:  DECF   58,F
....................       *ptr=make8(id,2) & 0x03;   //16:17 
068E:  MOVFF  58,FE9
0692:  MOVFF  59,FEA
0696:  MOVF   55,W
0698:  ANDLW  03
069A:  MOVWF  FEF
....................       *ptr|=(make8(id,2) << 3) & 0xE0; //18:20 
069C:  MOVFF  58,FE9
06A0:  MOVFF  59,FEA
06A4:  MOVFF  55,00
06A8:  RLCF   00,F
06AA:  RLCF   00,F
06AC:  RLCF   00,F
06AE:  MOVLW  F8
06B0:  ANDWF  00,F
06B2:  MOVF   00,W
06B4:  ANDLW  E0
06B6:  IORWF  FEF,W
06B8:  MOVWF  FEF
....................       *ptr|=0x08; 
06BA:  MOVFF  58,FE9
06BE:  MOVFF  59,FEA
06C2:  MOVF   FEF,W
06C4:  IORLW  08
06C6:  MOVWF  FEF
....................  
....................  
....................       //sidh 
....................       ptr--; 
06C8:  MOVF   58,W
06CA:  BTFSC  FD8.2
06CC:  DECF   59,F
06CE:  DECF   58,F
....................       *ptr=((make8(id,2) >> 5) & 0x07 ); //21:23 
06D0:  MOVFF  58,FE9
06D4:  MOVFF  59,FEA
06D8:  MOVFF  55,00
06DC:  SWAPF  00,F
06DE:  RRCF   00,F
06E0:  MOVLW  07
06E2:  ANDWF  00,F
06E4:  MOVF   00,W
06E6:  ANDLW  07
06E8:  MOVWF  FEF
....................       *ptr|=((make8(id,3) << 3) & 0xF8);//24:28 
06EA:  MOVFF  58,FE9
06EE:  MOVFF  59,FEA
06F2:  MOVFF  56,00
06F6:  RLCF   00,F
06F8:  RLCF   00,F
06FA:  RLCF   00,F
06FC:  MOVLW  F8
06FE:  ANDWF  00,F
0700:  MOVF   00,W
0702:  ANDLW  F8
0704:  IORWF  FEF,W
0706:  MOVWF  FEF
....................    } 
0708:  BRA    0788
....................    else {   //standard 
....................       //eidl 
....................       *ptr=0; 
070A:  MOVFF  58,FE9
070E:  MOVFF  59,FEA
0712:  CLRF   FEF
....................  
....................       //eidh 
....................       ptr--; 
0714:  MOVF   58,W
0716:  BTFSC  FD8.2
0718:  DECF   59,F
071A:  DECF   58,F
....................       *ptr=0; 
071C:  MOVFF  58,FE9
0720:  MOVFF  59,FEA
0724:  CLRF   FEF
....................  
....................       //sidl 
....................       ptr--; 
0726:  MOVF   58,W
0728:  BTFSC  FD8.2
072A:  DECF   59,F
072C:  DECF   58,F
....................       *ptr=(make8(id,0) << 5) & 0xE0; 
072E:  MOVFF  58,FE9
0732:  MOVFF  59,FEA
0736:  MOVFF  53,00
073A:  SWAPF  00,F
073C:  RLCF   00,F
073E:  MOVLW  E0
0740:  ANDWF  00,F
0742:  MOVF   00,W
0744:  ANDLW  E0
0746:  MOVWF  FEF
....................  
....................       //sidh 
....................       ptr--; 
0748:  MOVF   58,W
074A:  BTFSC  FD8.2
074C:  DECF   59,F
074E:  DECF   58,F
....................       *ptr=(make8(id,0) >> 3) & 0x1F; 
0750:  MOVFF  58,FE9
0754:  MOVFF  59,FEA
0758:  MOVFF  53,00
075C:  RRCF   00,F
075E:  RRCF   00,F
0760:  RRCF   00,F
0762:  MOVLW  1F
0764:  ANDWF  00,F
0766:  MOVF   00,W
0768:  ANDLW  1F
076A:  MOVWF  FEF
....................       *ptr|=(make8(id,1) << 5) & 0xE0; 
076C:  MOVFF  58,FE9
0770:  MOVFF  59,FEA
0774:  MOVFF  54,00
0778:  SWAPF  00,F
077A:  RLCF   00,F
077C:  MOVLW  E0
077E:  ANDWF  00,F
0780:  MOVF   00,W
0782:  ANDLW  E0
0784:  IORWF  FEF,W
0786:  MOVWF  FEF
....................    } 
0788:  RETURN 0
.................... } 
....................  
.................... //////////////////////////////////////////////////////////////////////// 
.................... // 
.................... // can_get_id() 
.................... // 
.................... // Returns the ID of the specified buffer.  (The opposite of can_set_id()) 
.................... // This is used after receiving a message, to see which ID sent the message. 
.................... // 
.................... //   Parameters: 
.................... //     addr - pointer to first byte of ID register, starting with xxxxEIDL. 
.................... //            For example, a pointer to RXM1EIDL 
.................... //     ext - Set to TRUE if this buffer uses an extended ID, FALSE if not 
.................... // 
.................... //   Returns: 
.................... //     The ID of the buffer 
.................... // 
.................... //////////////////////////////////////////////////////////////////////// 
.................... unsigned int32 can_get_id(unsigned int * addr, int1 ext) { 
....................    unsigned int32 ret; 
....................    unsigned int * ptr; 
....................  
....................    ret=0; 
....................    ptr=addr; 
....................  
....................    if (ext) { 
....................       ret=*ptr;  //eidl 
....................  
....................       ptr--;     //eidh 
....................       ret|=((unsigned int32)*ptr << 8); 
....................  
....................       ptr--;     //sidl 
....................       ret|=((unsigned int32)*ptr & 0x03) << 16; 
....................       ret|=((unsigned int32)*ptr & 0xE0) << 13; 
....................  
....................       ptr--;     //sidh 
....................       ret|=((unsigned int32)*ptr << 21); 
....................  
....................    } 
....................    else { 
....................       ptr-=2;    //sidl 
....................       ret=((unsigned int32)*ptr & 0xE0) >> 5; 
....................  
....................       ptr--;     //sidh 
....................       ret|=((unsigned int32)*ptr << 3); 
....................    } 
....................  
....................    return(ret); 
.................... } 
....................  
.................... //////////////////////////////////////////////////////////////////////// 
.................... // 
.................... // can_putd() 
.................... // 
.................... // Puts data on a transmit buffer, at which time the CAN peripheral will 
.................... // send when the CAN bus becomes available. 
.................... // 
.................... //    Parameters: 
.................... //       id - ID to transmit data as 
.................... //       data - pointer to data to send 
.................... //       len - length of data to send 
.................... //       priority - priority of message.  The higher the number, the 
.................... //                  sooner the CAN peripheral will send the message. 
.................... //                  Numbers 0 through 3 are valid. 
.................... //       ext - TRUE to use an extended ID, FALSE if not 
.................... //       rtr - TRUE to set the RTR (request) bit in the ID, false if NOT 
.................... // 
.................... //    Returns: 
.................... //       If successful, it will return TRUE 
.................... //       If un-successful, will return FALSE 
.................... // 
.................... //////////////////////////////////////////////////////////////////////// 
.................... int1 can_putd(unsigned int32 id, unsigned int * data, unsigned int len, unsigned int priority, int1 ext, int1 rtr) { 
....................    unsigned int i; 
....................    unsigned int * txd0; 
....................    unsigned int port; 
....................  
....................    txd0=&TXRXBaD0; 
*
1400:  MOVLW  0F
1402:  MOVWF  4F
1404:  MOVLW  66
1406:  MOVWF  4E
....................  
....................     // find empty transmitter 
....................     //map access bank addresses to empty transmitter 
....................    if (!TXB0CON.txreq) { 
1408:  MOVLB  F
140A:  BTFSC  x40.3
140C:  BRA    141A
....................       CANCON.win=CAN_WIN_TX0; 
140E:  MOVLW  F1
1410:  ANDWF  F6F,W
1412:  IORLW  08
1414:  MOVWF  F6F
....................       port=0; 
1416:  CLRF   50
....................    } 
1418:  BRA    1444
....................    else if (!TXB1CON.txreq) { 
141A:  BTFSC  x30.3
141C:  BRA    142C
....................       CANCON.win=CAN_WIN_TX1; 
141E:  MOVLW  F1
1420:  ANDWF  F6F,W
1422:  IORLW  06
1424:  MOVWF  F6F
....................       port=1; 
1426:  MOVLW  01
1428:  MOVWF  50
....................    } 
142A:  BRA    1444
....................    else if (!TXB2CON.txreq) { 
142C:  BTFSC  x20.3
142E:  BRA    143E
....................       CANCON.win=CAN_WIN_TX2; 
1430:  MOVLW  F1
1432:  ANDWF  F6F,W
1434:  IORLW  04
1436:  MOVWF  F6F
....................       port=2; 
1438:  MOVLW  02
143A:  MOVWF  50
....................    } 
143C:  BRA    1444
....................    else { 
....................       #if CAN_DO_DEBUG 
....................          can_debug("\r\nCAN_PUTD() FAIL: NO OPEN TX BUFFERS\r\n"); 
....................       #endif 
....................       return(0); 
143E:  MOVLW  00
1440:  MOVWF  01
1442:  BRA    14BC
....................    } 
....................  
....................    //set priority. 
....................    TXBaCON.txpri=priority; 
1444:  MOVF   4A,W
1446:  ANDLW  03
1448:  MOVWF  00
144A:  MOVLW  FC
144C:  ANDWF  F60,W
144E:  IORWF  00,W
1450:  MOVWF  F60
....................  
....................    //set tx mask 
....................    can_set_id(TXRXBaID, id, ext); 
1452:  MOVLW  0F
1454:  MOVWF  52
1456:  MOVLW  64
1458:  MOVWF  51
145A:  MOVFF  46,56
145E:  MOVFF  45,55
1462:  MOVFF  44,54
1466:  MOVFF  43,53
146A:  MOVFF  4B,57
146E:  MOVLB  0
1470:  CALL   065A
....................  
....................    //set tx data count 
....................    TXBaDLC=len; 
1474:  MOVFF  49,F65
....................    TXBaDLC.rtr=rtr; 
1478:  BCF    F65.6
147A:  BTFSC  4C.0
147C:  BSF    F65.6
....................  
....................     for (i=0; i<len; i++) { 
147E:  CLRF   4D
1480:  MOVF   49,W
1482:  SUBWF  4D,W
1484:  BC    14AE
....................       *txd0=*data; 
1486:  MOVFF  47,FE9
148A:  MOVFF  48,FEA
148E:  MOVFF  FEF,53
1492:  MOVFF  4F,FEA
1496:  MOVFF  4E,FE9
149A:  MOVFF  53,FEF
....................       txd0++; 
149E:  INCF   4E,F
14A0:  BTFSC  FD8.2
14A2:  INCF   4F,F
....................       data++; 
14A4:  INCF   47,F
14A6:  BTFSC  FD8.2
14A8:  INCF   48,F
14AA:  INCF   4D,F
14AC:  BRA    1480
....................     } 
....................  
....................    //enable transmission 
....................    TXBaCON.txreq=1; 
14AE:  BSF    F60.3
....................  
....................    CANCON.win=CAN_WIN_RX0; 
14B0:  MOVLW  F1
14B2:  ANDWF  F6F,W
14B4:  MOVWF  F6F
....................  
....................    #if CAN_DO_DEBUG 
....................             can_debug("\r\nCAN_PUTD(): BUFF=%U ID=%LX LEN=%U PRI=%U EXT=%U RTR=%U\r\n", port, id, len, priority, ext, rtr); 
....................             if ((len)&&(!rtr)) { 
....................                data-=len; 
....................                can_debug("  DATA = "); 
....................                for (i=0;i<len;i++) { 
....................                   can_debug("%X ",*data); 
....................                   data++; 
....................                } 
....................                can_debug("\r\n"); 
....................             } 
....................    #endif 
....................  
....................    return(1); 
14B6:  MOVLW  01
14B8:  MOVWF  01
14BA:  MOVLB  F
14BC:  MOVLB  0
14BE:  GOTO   1700 (RETURN)
.................... } 
....................  
.................... //////////////////////////////////////////////////////////////////////// 
.................... // 
.................... // can_getd() 
.................... // 
.................... // Gets data from a receive buffer, if the data exists 
.................... // 
.................... //    Returns: 
.................... //      id - ID who sent message 
.................... //      data - pointer to array of data 
.................... //      len - length of received data 
.................... //      stat - structure holding some information (such as which buffer 
.................... //             received it, ext or standard, etc) 
.................... // 
.................... //    Returns: 
.................... //      Function call returns a TRUE if there was data in a RX buffer, FALSE 
.................... //      if there was none. 
.................... // 
.................... //////////////////////////////////////////////////////////////////////// 
.................... int1 can_getd(unsigned int32 & id, unsigned int * data, unsigned int & len, struct rx_stat & stat) 
.................... { 
....................     unsigned int i; 
....................     unsigned int * ptr; 
....................  
....................     if (RXB0CON.rxful) { 
....................         CANCON.win=CAN_WIN_RX0; 
....................         stat.buffer=0; 
....................  
....................         CAN_INT_RXB0IF=0; 
....................  
....................         stat.err_ovfl=COMSTAT.rx0ovfl; 
....................         COMSTAT.rx0ovfl=0; 
....................  
....................         if (RXB0CON.rxb0dben) { 
....................          stat.filthit=RXB0CON.filthit0; 
....................         } 
....................     } 
....................     else if ( RXB1CON.rxful ) 
....................     { 
....................         CANCON.win=CAN_WIN_RX1; 
....................         stat.buffer=1; 
....................  
....................         CAN_INT_RXB1IF=0; 
....................  
....................         stat.err_ovfl=COMSTAT.rx1ovfl; 
....................         COMSTAT.rx1ovfl=0; 
....................  
....................         stat.filthit=RXB1CON.filthit; 
....................     } 
....................     else { 
....................       #if CAN_DO_DEBUG 
....................          can_debug("\r\nFAIL ON CAN_GETD(): NO MESSAGE IN BUFFER\r\n"); 
....................       #endif 
....................       return (0); 
....................     } 
....................  
....................     len = RXBaDLC.dlc; 
....................     stat.rtr=RXBaDLC.rtr; 
....................  
....................     stat.ext=TXRXBaSIDL.ext; 
....................     id=can_get_id(TXRXBaID,stat.ext); 
....................  
....................     ptr = &TXRXBaD0; 
....................     for ( i = 0; i < len; i++ ) { 
....................         *data = *ptr; 
....................         data++; 
....................         ptr++; 
....................     } 
....................  
....................     // return to default addressing 
....................     CANCON.win=CAN_WIN_RX0; 
....................  
....................     stat.inv=CAN_INT_IRXIF; 
....................     CAN_INT_IRXIF = 0; 
....................  
....................     if (stat.buffer) { 
....................       RXB1CON.rxful=0; 
....................     } 
....................     else { 
....................       RXB0CON.rxful=0; 
....................     } 
....................  
....................     #if CAN_DO_DEBUG 
....................        can_debug("\r\nCAN_GETD(): BUFF=%U ID=%LX LEN=%U OVF=%U ", stat.buffer, id, len, stat.err_ovfl); 
....................        can_debug("FILT=%U RTR=%U EXT=%U INV=%U", stat.filthit, stat.rtr, stat.ext, stat.inv); 
....................        if ((len)&&(!stat.rtr)) { 
....................           data-=len; 
....................           can_debug("\r\n    DATA = "); 
....................           for (i=0;i<len;i++) { 
....................             can_debug("%X ",*data); 
....................             data++; 
....................           } 
....................        } 
....................        can_debug("\r\n"); 
....................     #endif 
....................  
....................     return(1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... #include <spd800.c> 
.................... //-----------------------------------------------------------------------------  
.................... // This is the crc8 function for use on the PIC16 and PIC18 etc. microprocessors  
.................... int crc8( unsigned int8 *data, unsigned int8 len) 
*
0A68:  SETF   x61
.................... { 
....................   // adapted from SHT21 sample code from 
....................   // http://www.sensirion.com/en/products/humidity-temperature/download-center/ 
....................   // x^8 + x^5 + x^4 + 1 
....................   unsigned int8 crc = 0xff; 
....................   unsigned int8 byteCtr; 
....................   for (byteCtr = 0; byteCtr < len; ++byteCtr) { 
0A6A:  CLRF   x62
0A6C:  MOVF   x60,W
0A6E:  SUBWF  x62,W
0A70:  BC    0AA4
....................     crc ^= data[byteCtr]; 
0A72:  MOVF   x62,W
0A74:  ADDWF  5E,W
0A76:  MOVWF  FE9
0A78:  MOVLW  00
0A7A:  ADDWFC 5F,W
0A7C:  MOVWF  FEA
0A7E:  MOVF   FEF,W
0A80:  XORWF  x61,F
....................     for (unsigned int8 bit = 8; bit > 0; --bit) { 
0A82:  MOVLW  08
0A84:  MOVWF  x63
0A86:  MOVF   x63,F
0A88:  BZ    0AA0
....................       if (crc & 0x80) { 
0A8A:  BTFSS  x61.7
0A8C:  BRA    0A98
....................         crc = (crc << 1) ^ 0x31; 
0A8E:  BCF    FD8.0
0A90:  RLCF   x61,W
0A92:  XORLW  31
0A94:  MOVWF  x61
....................       } else { 
0A96:  BRA    0A9C
....................         crc = (crc << 1); 
0A98:  BCF    FD8.0
0A9A:  RLCF   x61,F
....................       } 
0A9C:  DECF   x63,F
0A9E:  BRA    0A86
....................     } 
0AA0:  INCF   x62,F
0AA2:  BRA    0A6C
....................   } 
....................   return crc; 
0AA4:  MOVFF  61,01
0AA8:  RETURN 0
.................... } 
....................  
.................... void cmd_continuous_measure() 
.................... { 
....................       int status, status1, status2; 
....................       i2c_start();  
....................       status = i2c_write(0x4A); // CHECK WITH SPD800 ID = 25  // 0 is ACK     
....................       printf("\r\n continuous measure write(0x4A): %u",status); 
....................        
....................       status1 = i2c_write(0x36);                        // 0 is ACK 
....................       printf("\r\n continuous measure write(0x36): %u",status1); 
....................         
....................       status2 = i2c_write(0x1E);  
....................       printf("\r\n continuous measure write(0x15): %u",status2);      // 0 is ACK 
....................        
....................       i2c_stop(); 
....................       delay_ms(5); 
.................... } 
....................  
.................... void stopmeasure() 
.................... { 
....................       int status, status1, status2; 
....................       i2c_start();  
....................       status = i2c_write(0x4A); // CHECK WITH SPD800 ID = 25  // 0 is ACK     
....................       printf("\r\n stop write(0x4A): %u",status); 
....................        
....................       status1 = i2c_write(0x3F);                        // 0 is ACK 
....................       printf("\r\n stop write(0x3F): %u",status1); 
....................         
....................       status2 = i2c_write(0xF9);  
....................       printf("\r\n stop write(0xF9): %u",status2);      // 0 is ACK 
....................        
....................       i2c_stop(); 
....................       delay_ms(5); 
.................... } 
.................... void softreset(void) 
.................... { 
....................       int  status1, status2; 
....................       i2c_start();  
*
0936:  BSF    FC5.0
0938:  BTFSC  FC5.0
093A:  BRA    0938
....................       // Note that ID_address in this case is 0x00       
....................       status1 = i2c_write(0x00);                        // 0 is ACK 
093C:  CLRF   5E
093E:  RCALL  0866
0940:  MOVFF  01,41
....................       printf("\r\n reset write(0x00): %u",status1); 
0944:  MOVLW  68
0946:  MOVWF  FF6
0948:  MOVLW  01
094A:  MOVWF  FF7
094C:  MOVLW  16
094E:  MOVWF  5E
0950:  RCALL  0882
0952:  MOVFF  41,44
0956:  MOVLW  1B
0958:  MOVWF  45
095A:  RCALL  08CA
....................         
....................       status2 = i2c_write(0x06);  
095C:  MOVLW  06
095E:  MOVWF  5E
0960:  RCALL  0866
0962:  MOVFF  01,42
....................       printf("\r\n reset write(0x06): %u",status2);      // 0 is ACK 
0966:  MOVLW  82
0968:  MOVWF  FF6
096A:  MOVLW  01
096C:  MOVWF  FF7
096E:  MOVLW  16
0970:  MOVWF  5E
0972:  RCALL  0882
0974:  MOVFF  42,44
0978:  MOVLW  1B
097A:  MOVWF  45
097C:  RCALL  08CA
....................        
....................       i2c_stop(); 
097E:  BSF    FC5.2
0980:  BTFSC  FC5.2
0982:  BRA    0980
....................       delay_ms(20); 
0984:  MOVLW  14
0986:  MOVWF  5E
0988:  RCALL  05E2
098A:  RETURN 0
....................  
.................... } 
.................... void identifier() 
.................... { 
....................  
....................       BYTE data[11]; 
....................       int8 status, status1, status2, status3, status4, status5; 
....................        
....................        i2c_start();  
....................       status = i2c_write(0x4A); // CHECK WITH SPD800 ID = 25  // 0 is ACK     
....................       printf("\r\nSensirion status: %u",status); 
....................        
....................       status1 = i2c_write(0x36);                        // 0 is ACK 
....................       printf("\r\nSensirion status1: %u",status1); 
....................        
....................       status2 = i2c_write(0x7C);  
....................       printf("\r\nSensirion status2: %u",status2);      // 0 is ACK 
....................       i2c_stop(); 
....................       i2c_start();  
....................       status = i2c_write(0x4A); // CHECK WITH SPD800 ID = 25  // 0 is ACK     
....................       printf("\r\nSensirion status3: %u",status3); 
....................        
....................       status1 = i2c_write(0xE1);                        // 0 is ACK 
....................       printf("\r\nSensirion status4: %u",status4); 
....................        
....................       status2 = i2c_write(0x02);  
....................       printf("\r\nSensirion status5: %u",status5);      // 0 is ACK 
....................    
....................       i2c_start();  
....................       i2c_write(0x4B);  
....................       data[0] = i2c_read(1); // 1 is ACK 
....................       data[1] = i2c_read(1); // 1 is ACK 
....................       data[2] = i2c_read(1); // 1 is ACK   
....................       data[3] = i2c_read(1); // 1 is ACK 
....................       data[4] = i2c_read(1); // 1 is ACK 
....................       data[5] = i2c_read(1); // 1 is ACK         
....................       data[6] = i2c_read(1); // 1 is ACK 
....................       data[7] = i2c_read(1); // 1 is ACK           
....................        
....................       i2c_stop();    
....................       delay_us(20); 
....................       printf("\r\nSensirion ID DATA[0]: %02X",data[0]); 
....................       printf("\r\nSensirion ID DATA[1]: %02X",data[1]); 
....................       printf("\r\nSensirion ID DATA[2]: %02X",data[2]); 
....................       printf("\r\nSensirion ID DATA[3]: %02X",data[3]); 
....................       printf("\r\nSensirion ID DATA[4]: %02X",data[4]); 
....................       printf("\r\nSensirion ID DATA[5]: %02X",data[5]); 
....................       printf("\r\nSensirion ID DATA[6]: %02X",data[6]);      
.................... } 
....................  
....................  
.................... int8  cmd_pressure(void) 
.................... { 
....................         BYTE status, status1, status2;       
....................       i2c_start();  
098C:  BSF    FC5.0
098E:  BTFSC  FC5.0
0990:  BRA    098E
....................       status = i2c_write(0x4A); // CHECK WITH SPD800 ID = 25  // 0 is ACK     
0992:  MOVLW  4A
0994:  MOVWF  5E
0996:  RCALL  0866
0998:  MOVFF  01,41
....................       printf("\r\nSensirion status: %u",status); 
099C:  MOVLW  FE
099E:  MOVWF  FF6
09A0:  MOVLW  02
09A2:  MOVWF  FF7
09A4:  MOVLW  14
09A6:  MOVWF  5E
09A8:  RCALL  0882
09AA:  MOVFF  41,44
09AE:  MOVLW  1B
09B0:  MOVWF  45
09B2:  RCALL  08CA
....................        
....................       status1 = i2c_write(0x36);                        // 0 is ACK, different pressure 
09B4:  MOVLW  36
09B6:  MOVWF  5E
09B8:  RCALL  0866
09BA:  MOVFF  01,42
....................       printf("\r\nSensirion status1: %u",status1); 
09BE:  MOVLW  16
09C0:  MOVWF  FF6
09C2:  MOVLW  03
09C4:  MOVWF  FF7
09C6:  MOVLW  15
09C8:  MOVWF  5E
09CA:  RCALL  0882
09CC:  MOVFF  42,44
09D0:  MOVLW  1B
09D2:  MOVWF  45
09D4:  RCALL  08CA
....................        
....................       status2 = i2c_write(0x15);                        // 0 is ACK, different pressure, 2F 
09D6:  MOVLW  15
09D8:  MOVWF  5E
09DA:  RCALL  0866
09DC:  MOVFF  01,43
....................       printf("\r\nSensirion status2: %u",status2); 
09E0:  MOVLW  2E
09E2:  MOVWF  FF6
09E4:  MOVLW  03
09E6:  MOVWF  FF7
09E8:  MOVLW  15
09EA:  MOVWF  5E
09EC:  RCALL  0882
09EE:  MOVFF  43,44
09F2:  MOVLW  1B
09F4:  MOVWF  45
09F6:  RCALL  08CA
....................       i2c_stop(); 
09F8:  BSF    FC5.2
09FA:  BTFSC  FC5.2
09FC:  BRA    09FA
....................       if(status2 == 0) 
09FE:  MOVF   43,F
0A00:  BNZ   0A06
....................       return true; 
0A02:  MOVLW  01
0A04:  MOVWF  01
0A06:  GOTO   163E (RETURN)
....................  
.................... } 
.................... float measure_pressure(void) 
.................... { 
....................  union conv {  
....................     signed int16 f;  
....................     int8 b[2]; 
....................   }; 
....................   union conv  diffpressure, temp, scale;  // p is alias pointer 
....................    BYTE  check1, check2, check3; 
....................    BYTE data[10]; 
....................    float pressure, temperature;  
....................   unsigned int16 scale_factor; 
....................    
....................       delay_ms(12); // in trigger mode delay_ms(50) 
*
10AC:  MOVLW  0C
10AE:  MOVWF  5E
10B0:  CALL   05E2
....................       i2c_start(); 
10B4:  BSF    FC5.0
10B6:  BTFSC  FC5.0
10B8:  BRA    10B6
....................       i2c_write(0x4B);  
10BA:  MOVLW  4B
10BC:  MOVWF  5E
10BE:  CALL   0866
....................      
....................       data[1] = i2c_read(1); // 1 is ACK 
10C2:  MOVLW  01
10C4:  MOVWF  00
10C6:  RCALL  0A0A
10C8:  MOVFF  01,4B
....................       data[2] = i2c_read(1); // 1 is ACK 
10CC:  MOVLW  01
10CE:  MOVWF  00
10D0:  RCALL  0A0A
10D2:  MOVFF  01,4C
....................       data[3] = i2c_read(1); // 1 is ACK   
10D6:  MOVLW  01
10D8:  MOVWF  00
10DA:  RCALL  0A0A
10DC:  MOVFF  01,4D
....................       data[4] = i2c_read(1); // 1 is ACK 
10E0:  MOVLW  01
10E2:  MOVWF  00
10E4:  RCALL  0A0A
10E6:  MOVFF  01,4E
....................       data[5] = i2c_read(1); // 1 is ACK 
10EA:  MOVLW  01
10EC:  MOVWF  00
10EE:  RCALL  0A0A
10F0:  MOVFF  01,4F
....................       data[6] = i2c_read(1); // 1 is ACK         
10F4:  MOVLW  01
10F6:  MOVWF  00
10F8:  RCALL  0A0A
10FA:  MOVFF  01,50
....................       data[7] = i2c_read(1); // 1 is ACK 
10FE:  MOVLW  01
1100:  MOVWF  00
1102:  RCALL  0A0A
1104:  MOVFF  01,51
....................       data[8] = i2c_read(1); // 1 is ACK    
1108:  MOVLW  01
110A:  MOVWF  00
110C:  RCALL  0A0A
110E:  MOVFF  01,52
....................       data[9] = i2c_read(1); // 1 is ACK 
1112:  MOVLW  01
1114:  MOVWF  00
1116:  RCALL  0A0A
1118:  MOVFF  01,53
....................  
....................   
....................       i2c_stop(); 
111C:  BSF    FC5.2
111E:  BTFSC  FC5.2
1120:  BRA    111E
....................       delay_ms(1); 
1122:  MOVLW  01
1124:  MOVWF  5E
1126:  CALL   05E2
....................        
....................       printf("\r\nDifferent pressure DATA[0]: %02X",data[0]); 
112A:  MOVLW  46
112C:  MOVWF  FF6
112E:  MOVLW  03
1130:  MOVWF  FF7
1132:  MOVLW  1E
1134:  MOVWF  5E
1136:  CALL   0882
113A:  MOVFF  4A,5E
113E:  MOVLW  37
1140:  MOVWF  5F
1142:  RCALL  0A26
....................       printf("\r\nDifferent pressure DATA[1]: %02X",data[1]); 
1144:  MOVLW  6A
1146:  MOVWF  FF6
1148:  MOVLW  03
114A:  MOVWF  FF7
114C:  MOVLW  1E
114E:  MOVWF  5E
1150:  CALL   0882
1154:  MOVFF  4B,5E
1158:  MOVLW  37
115A:  MOVWF  5F
115C:  RCALL  0A26
....................       printf("\r\nDifferent pressure DATA[2]: %02X",data[2]); 
115E:  MOVLW  8E
1160:  MOVWF  FF6
1162:  MOVLW  03
1164:  MOVWF  FF7
1166:  MOVLW  1E
1168:  MOVWF  5E
116A:  CALL   0882
116E:  MOVFF  4C,5E
1172:  MOVLW  37
1174:  MOVWF  5F
1176:  RCALL  0A26
....................       printf("\r\nDifferent pressure DATA[3]: %02X",data[3]); 
1178:  MOVLW  B2
117A:  MOVWF  FF6
117C:  MOVLW  03
117E:  MOVWF  FF7
1180:  MOVLW  1E
1182:  MOVWF  5E
1184:  CALL   0882
1188:  MOVFF  4D,5E
118C:  MOVLW  37
118E:  MOVWF  5F
1190:  RCALL  0A26
....................       printf("\r\nDifferent pressure DATA[4]: %02X",data[4]); 
1192:  MOVLW  D6
1194:  MOVWF  FF6
1196:  MOVLW  03
1198:  MOVWF  FF7
119A:  MOVLW  1E
119C:  MOVWF  5E
119E:  CALL   0882
11A2:  MOVFF  4E,5E
11A6:  MOVLW  37
11A8:  MOVWF  5F
11AA:  RCALL  0A26
....................       printf("\r\nDifferent pressure DATA[5]: %02X",data[5]); 
11AC:  MOVLW  FA
11AE:  MOVWF  FF6
11B0:  MOVLW  03
11B2:  MOVWF  FF7
11B4:  MOVLW  1E
11B6:  MOVWF  5E
11B8:  CALL   0882
11BC:  MOVFF  4F,5E
11C0:  MOVLW  37
11C2:  MOVWF  5F
11C4:  RCALL  0A26
....................       printf("\r\nDifferent pressure DATA[6]: %02X",data[6]);    
11C6:  MOVLW  1E
11C8:  MOVWF  FF6
11CA:  MOVLW  04
11CC:  MOVWF  FF7
11CE:  MOVLW  1E
11D0:  MOVWF  5E
11D2:  CALL   0882
11D6:  MOVFF  50,5E
11DA:  MOVLW  37
11DC:  MOVWF  5F
11DE:  RCALL  0A26
....................       printf("\r\nDifferent pressure DATA[7]: %02X",data[7]); 
11E0:  MOVLW  42
11E2:  MOVWF  FF6
11E4:  MOVLW  04
11E6:  MOVWF  FF7
11E8:  MOVLW  1E
11EA:  MOVWF  5E
11EC:  CALL   0882
11F0:  MOVFF  51,5E
11F4:  MOVLW  37
11F6:  MOVWF  5F
11F8:  RCALL  0A26
....................       printf("\r\nDifferent pressure DATA[8]: %02X",data[8]); 
11FA:  MOVLW  66
11FC:  MOVWF  FF6
11FE:  MOVLW  04
1200:  MOVWF  FF7
1202:  MOVLW  1E
1204:  MOVWF  5E
1206:  CALL   0882
120A:  MOVFF  52,5E
120E:  MOVLW  37
1210:  MOVWF  5F
1212:  RCALL  0A26
....................       printf("\r\nDifferent pressure DATA[9]: %02X",data[9]);  
1214:  MOVLW  8A
1216:  MOVWF  FF6
1218:  MOVLW  04
121A:  MOVWF  FF7
121C:  MOVLW  1E
121E:  MOVWF  5E
1220:  CALL   0882
1224:  MOVFF  53,5E
1228:  MOVLW  37
122A:  MOVWF  5F
122C:  CALL   0A26
....................        
....................       // crc-8 0x31(x^8 + x^5 + x^4 + 1) 
....................       // Initialization 0xFF 
....................       check1 = crc8(&data[1],2); 
1230:  CLRF   5F
1232:  MOVLW  4B
1234:  MOVWF  5E
1236:  MOVLW  02
1238:  MOVWF  x60
123A:  RCALL  0A68
123C:  MOVFF  01,47
....................       check2 = crc8(&data[4],2); 
1240:  CLRF   5F
1242:  MOVLW  4E
1244:  MOVWF  5E
1246:  MOVLW  02
1248:  MOVWF  x60
124A:  RCALL  0A68
124C:  MOVFF  01,48
....................       check3 = crc8(&data[7],2); 
1250:  CLRF   5F
1252:  MOVLW  51
1254:  MOVWF  5E
1256:  MOVLW  02
1258:  MOVWF  x60
125A:  RCALL  0A68
125C:  MOVFF  01,49
....................        
....................       printf("\r\nCheck 1: %02X",check1); 
1260:  MOVLW  AE
1262:  MOVWF  FF6
1264:  MOVLW  04
1266:  MOVWF  FF7
1268:  MOVLW  0B
126A:  MOVWF  5E
126C:  CALL   0882
1270:  MOVFF  47,5E
1274:  MOVLW  37
1276:  MOVWF  5F
1278:  CALL   0A26
....................       printf("\r\nCheck 2: %02X",check2); 
127C:  MOVLW  BE
127E:  MOVWF  FF6
1280:  MOVLW  04
1282:  MOVWF  FF7
1284:  MOVLW  0B
1286:  MOVWF  5E
1288:  CALL   0882
128C:  MOVFF  48,5E
1290:  MOVLW  37
1292:  MOVWF  5F
1294:  CALL   0A26
....................       printf("\r\nCheck 3: %02X",check3);  
1298:  MOVLW  CE
129A:  MOVWF  FF6
129C:  MOVLW  04
129E:  MOVWF  FF7
12A0:  MOVLW  0B
12A2:  MOVWF  5E
12A4:  CALL   0882
12A8:  MOVFF  49,5E
12AC:  MOVLW  37
12AE:  MOVWF  5F
12B0:  CALL   0A26
....................        
....................        diffpressure.b[0] = data[0]; 
12B4:  MOVFF  4A,41
....................        diffpressure.b[1] = data[1]; 
12B8:  MOVFF  4B,42
....................        temp.b[0] = data[3]; //data[3] 
12BC:  MOVFF  4D,43
....................        temp.b[1] = data[4]; //data[4] 
12C0:  MOVFF  4E,44
....................        scale.b[0] = data[7]; 
12C4:  MOVFF  51,45
....................        scale.b[1] = data[8]; 
12C8:  MOVFF  52,46
....................        scale_factor = make16(data[7], data[8]); 
12CC:  MOVFF  51,5D
12D0:  MOVFF  52,5C
....................        temperature = (float)temp.f / 200; 
12D4:  MOVFF  44,5F
12D8:  MOVFF  43,5E
12DC:  CALL   0AAA
12E0:  MOVFF  03,61
12E4:  MOVFF  02,60
12E8:  MOVFF  01,5F
12EC:  MOVFF  00,5E
12F0:  MOVFF  03,65
12F4:  MOVFF  02,64
12F8:  MOVFF  01,63
12FC:  MOVFF  00,62
1300:  CLRF   x69
1302:  CLRF   x68
1304:  MOVLW  48
1306:  MOVWF  x67
1308:  MOVLW  86
130A:  MOVWF  x66
130C:  CALL   0AF2
1310:  MOVFF  03,5B
1314:  MOVFF  02,5A
1318:  MOVFF  01,59
131C:  MOVFF  00,58
....................        pressure = ((float)diffpressure.f)/((float)scale_factor); 
1320:  MOVFF  42,5F
1324:  MOVFF  41,5E
1328:  CALL   0AAA
132C:  MOVFF  03,61
1330:  MOVFF  02,60
1334:  MOVFF  01,5F
1338:  MOVFF  00,5E
133C:  MOVFF  5D,63
1340:  MOVFF  5C,62
1344:  BRA    0C4C
1346:  MOVFF  61,65
134A:  MOVFF  60,64
134E:  MOVFF  5F,63
1352:  MOVFF  5E,62
1356:  MOVFF  03,69
135A:  MOVFF  02,68
135E:  MOVFF  01,67
1362:  MOVFF  00,66
1366:  CALL   0AF2
136A:  MOVFF  03,57
136E:  MOVFF  02,56
1372:  MOVFF  01,55
1376:  MOVFF  00,54
....................       // pressure = pressure; 
....................        printf("\r\nScale factor value: %Ld",scale_factor ); 
137A:  MOVLW  DE
137C:  MOVWF  FF6
137E:  MOVLW  04
1380:  MOVWF  FF7
1382:  MOVLW  16
1384:  MOVWF  5E
1386:  CALL   0882
138A:  MOVLW  10
138C:  MOVWF  FE9
138E:  MOVFF  5D,5F
1392:  MOVFF  5C,5E
1396:  BRA    0C84
....................        printf("\r\nTempeature value: %3.1f",temperature ); 
1398:  MOVLW  F8
139A:  MOVWF  FF6
139C:  MOVLW  04
139E:  MOVWF  FF7
13A0:  MOVLW  14
13A2:  MOVWF  5E
13A4:  CALL   0882
13A8:  MOVLW  02
13AA:  MOVWF  FE9
13AC:  MOVFF  5B,61
13B0:  MOVFF  5A,60
13B4:  MOVFF  59,5F
13B8:  MOVFF  58,5E
13BC:  MOVLW  01
13BE:  MOVWF  x62
13C0:  RCALL  0F2C
....................        printf("\r\nPressure value: %3.1f",pressure ); 
13C2:  MOVLW  12
13C4:  MOVWF  FF6
13C6:  MOVLW  05
13C8:  MOVWF  FF7
13CA:  MOVLW  12
13CC:  MOVWF  5E
13CE:  CALL   0882
13D2:  MOVLW  02
13D4:  MOVWF  FE9
13D6:  MOVFF  57,61
13DA:  MOVFF  56,60
13DE:  MOVFF  55,5F
13E2:  MOVFF  54,5E
13E6:  MOVLW  01
13E8:  MOVWF  x62
13EA:  RCALL  0F2C
....................        return pressure; 
13EC:  MOVFF  54,00
13F0:  MOVFF  55,01
13F4:  MOVFF  56,02
13F8:  MOVFF  57,03
13FC:  GOTO   1646 (RETURN)
....................  
....................   
.................... } 
....................  
....................  
....................  
.................... int16 ms; 
....................  
.................... #int_timer2 
.................... void isr_timer2(void) { 
....................    ms++; //keep a running timer that increments every milli-second 
*
052A:  INCF   19,F
052C:  BTFSC  FD8.2
052E:  INCF   1A,F
0530:  BCF    F9E.1
0532:  GOTO   0060
.................... } 
....................  
....................  
.................... //-----------------------------------------------------------------------------  
.................... // This is the crc8 function for use on the PIC16 and PIC18 etc. microprocessors  
....................  
.................... void main() { 
*
156A:  CLRF   FF8
156C:  BCF    FD0.7
156E:  BSF    07.7
1570:  BSF    F94.3
1572:  BSF    F94.4
1574:  MOVLW  09
1576:  MOVWF  FC8
1578:  MOVLW  28
157A:  MOVWF  FC6
157C:  BCF    FC7.7
157E:  BCF    FC7.6
1580:  BSF    FB8.3
1582:  MOVLW  81
1584:  MOVWF  FAF
1586:  MOVLW  00
1588:  MOVWF  FB0
158A:  MOVLW  A6
158C:  MOVWF  FAC
158E:  MOVLW  90
1590:  MOVWF  FAB
1592:  MOVF   FC1,W
1594:  ANDLW  C0
1596:  IORLW  0F
1598:  MOVWF  FC1
159A:  CLRF   34
159C:  CLRF   33
159E:  CLRF   32
15A0:  MOVLW  15
15A2:  MOVWF  31
15A4:  BCF    35.0
15A6:  BSF    35.1
15A8:  MOVLW  08
15AA:  MOVWF  36
15AC:  MOVLW  03
15AE:  MOVWF  37
....................    
....................    struct rx_stat rxstat; 
....................    int32 rx_id; 
....................    int in_data[8]; 
....................    int rx_len; 
....................  
.................... //send a request (tx_rtr=1) for 8 bytes of data (tx_len=8) from id 24 (tx_id=24) 
....................    int out_data[8]; 
....................    int32 tx_id=21; // id = 0x29 for MAX31855 temperature 
....................     
....................    int1 tx_rtr=0;// CU LA 1 
....................    int1 tx_ext=1;// CU LA 0 
....................    int tx_len=8; 
....................    int tx_pri=3; 
....................  
....................    int i; 
....................    
....................     
....................    for (i=0;i<8;i++) { 
15B0:  CLRF   38
15B2:  MOVF   38,W
15B4:  SUBLW  07
15B6:  BNC   15DE
....................       out_data[i]=0x33; 
15B8:  CLRF   03
15BA:  MOVF   38,W
15BC:  ADDLW  29
15BE:  MOVWF  FE9
15C0:  MOVLW  00
15C2:  ADDWFC 03,W
15C4:  MOVWF  FEA
15C6:  MOVLW  33
15C8:  MOVWF  FEF
....................       in_data[i]=0; 
15CA:  CLRF   03
15CC:  MOVF   38,W
15CE:  ADDLW  20
15D0:  MOVWF  FE9
15D2:  MOVLW  00
15D4:  ADDWFC 03,W
15D6:  MOVWF  FEA
15D8:  CLRF   FEF
15DA:  INCF   38,F
15DC:  BRA    15B2
....................     
....................       
....................    } 
....................  
....................  //////////////////// 
....................   
....................   union conv {  
....................     float f;  
....................     int8 b[4];  
....................   }; 
....................   union conv RSCPressure;  // p is alias pointer 
....................    
....................   float pressure; 
....................   
....................   
....................  
....................    printf("\r\n\r\nCCS CAN EXAMPLE\r\n"); 
15DE:  MOVLW  36
15E0:  MOVWF  FF6
15E2:  MOVLW  05
15E4:  MOVWF  FF7
15E6:  CALL   05C0
....................    setup_timer_2(T2_DIV_BY_4,79,16);   //setup up timer2 to interrupt every 1ms if using 20Mhz clock 
15EA:  MOVLW  78
15EC:  IORLW  05
15EE:  MOVWF  FCA
15F0:  MOVLW  4F
15F2:  MOVWF  FCB
....................    delay_ms(200); 
15F4:  MOVLW  C8
15F6:  MOVWF  5E
15F8:  CALL   05E2
....................    can_init(); 
15FC:  GOTO   078A
....................    
....................    enable_interrupts(INT_TIMER2);   //enable timer2 interrupt 
1600:  BSF    F9D.1
....................    enable_interrupts(GLOBAL);       //enable all interrupts (else timer2 wont happen) 
1602:  MOVLW  C0
1604:  IORWF  FF2,F
....................    printf("\r\nRunning..."); 
1606:  MOVLW  4C
1608:  MOVWF  FF6
160A:  MOVLW  05
160C:  MOVWF  FF7
160E:  CALL   05C0
....................   
....................    delay_ms(10); 
1612:  MOVLW  0A
1614:  MOVWF  5E
1616:  CALL   05E2
....................       softreset(); 
161A:  CALL   0936
....................       delay_ms(20);   
161E:  MOVLW  14
1620:  MOVWF  5E
1622:  CALL   05E2
....................      // cmd_continuous_measure(); 
....................    while(TRUE) 
....................    {    
....................          
....................       //stopmeasure(); 
....................       //delay_ms(5); 
....................      
....................       softreset(); 
1626:  CALL   0936
....................       delay_ms(50); 
162A:  MOVLW  32
162C:  MOVWF  5E
162E:  CALL   05E2
....................     //  identifier(); 
....................       delay_ms(50);     
1632:  MOVLW  32
1634:  MOVWF  5E
1636:  CALL   05E2
....................      // cmd_continuous_measure(); 
....................      while(cmd_pressure()) 
163A:  GOTO   098C
163E:  MOVF   01,F
1640:  BTFSC  FD8.2
1642:  BRA    1860
....................      { 
....................          
....................       
....................         pressure = measure_pressure(); 
1644:  BRA    10AC
1646:  MOVFF  03,40
164A:  MOVFF  02,3F
164E:  MOVFF  01,3E
1652:  MOVFF  00,3D
....................         RSCPressure.f = pressure; 
1656:  MOVFF  40,3C
165A:  MOVFF  3F,3B
165E:  MOVFF  3E,3A
1662:  MOVFF  3D,39
....................         out_data[0] = RSCPressure.b[0]; 
1666:  MOVFF  39,29
....................         out_data[1] = RSCPressure.b[1]; 
166A:  MOVFF  3A,2A
....................         out_data[2] = RSCPressure.b[2]; 
166E:  MOVFF  3B,2B
....................         out_data[3] = RSCPressure.b[3]; 
1672:  MOVFF  3C,2C
....................       printf("\r\nPressure value: %3.1f",pressure );      
1676:  MOVLW  5A
1678:  MOVWF  FF6
167A:  MOVLW  05
167C:  MOVWF  FF7
167E:  MOVLW  12
1680:  MOVWF  5E
1682:  CALL   0882
1686:  MOVLW  02
1688:  MOVWF  FE9
168A:  MOVFF  40,61
168E:  MOVFF  3F,60
1692:  MOVFF  3E,5F
1696:  MOVFF  3D,5E
169A:  MOVLW  01
169C:  MOVWF  x62
169E:  RCALL  0F2C
....................        
....................        if ( can_tbe() && (ms > 2000)) 
16A0:  MOVLB  F
16A2:  BTFSS  x40.3
16A4:  BRA    16AE
16A6:  BTFSS  x30.3
16A8:  BRA    16AE
16AA:  BTFSC  x20.3
16AC:  BRA    1846
16AE:  MOVF   1A,W
16B0:  SUBLW  06
16B2:  BTFSC  FD8.0
16B4:  BRA    1846
16B6:  XORLW  FF
16B8:  BNZ   16C2
16BA:  MOVF   19,W
16BC:  SUBLW  D0
16BE:  BTFSC  FD8.0
16C0:  BRA    1846
....................         { 
....................          ms=0; 
16C2:  CLRF   1A
16C4:  CLRF   19
....................          i=can_putd(tx_id, out_data, tx_len,tx_pri,tx_ext,tx_rtr); //put data on transmit buffer 
16C6:  MOVLW  00
16C8:  BTFSC  35.1
16CA:  MOVLW  01
16CC:  MOVWF  41
16CE:  MOVLW  00
16D0:  BTFSC  35.0
16D2:  MOVLW  01
16D4:  MOVWF  42
16D6:  MOVFF  34,46
16DA:  MOVFF  33,45
16DE:  MOVFF  32,44
16E2:  MOVFF  31,43
16E6:  CLRF   48
16E8:  MOVLW  29
16EA:  MOVWF  47
16EC:  MOVFF  36,49
16F0:  MOVFF  37,4A
16F4:  MOVFF  41,4B
16F8:  MOVFF  42,4C
16FC:  MOVLB  0
16FE:  BRA    1400
1700:  MOVFF  01,38
....................          if (i != 0xFF) { //success, a transmit buffer was open 
1704:  INCFSZ 38,W
1706:  BRA    170A
1708:  BRA    1838
....................             printf("\r\nPUT %U: ID=%LU LEN=%U ", i, tx_id, tx_len);  //i return 1 if transmit success 
170A:  MOVLW  72
170C:  MOVWF  FF6
170E:  MOVLW  05
1710:  MOVWF  FF7
1712:  MOVLW  06
1714:  MOVWF  5E
1716:  CALL   0882
171A:  MOVFF  38,44
171E:  MOVLW  1B
1720:  MOVWF  45
1722:  CALL   08CA
1726:  MOVLW  7A
1728:  MOVWF  FF6
172A:  MOVLW  05
172C:  MOVWF  FF7
172E:  MOVLW  05
1730:  MOVWF  5E
1732:  CALL   0882
1736:  MOVLW  41
1738:  MOVWF  FE9
173A:  MOVFF  34,44
173E:  MOVFF  33,43
1742:  MOVFF  32,42
1746:  MOVFF  31,41
174A:  BRA    14C2
174C:  MOVLW  82
174E:  MOVWF  FF6
1750:  MOVLW  05
1752:  MOVWF  FF7
1754:  MOVLW  05
1756:  MOVWF  5E
1758:  CALL   0882
175C:  MOVFF  36,44
1760:  MOVLW  1B
1762:  MOVWF  45
1764:  CALL   08CA
1768:  MOVLW  20
176A:  BTFSS  F9E.4
176C:  BRA    176A
176E:  MOVWF  FAD
....................             printf("PRI=%U EXT=%U RTR=%U\r\n   DATA = ", tx_pri, tx_ext, tx_rtr); 
1770:  MOVLW  00
1772:  BTFSC  35.1
1774:  MOVLW  01
1776:  MOVWF  41
1778:  MOVLW  00
177A:  BTFSC  35.0
177C:  MOVLW  01
177E:  MOVWF  42
1780:  MOVLW  8C
1782:  MOVWF  FF6
1784:  MOVLW  05
1786:  MOVWF  FF7
1788:  MOVLW  04
178A:  MOVWF  5E
178C:  CALL   0882
1790:  MOVFF  37,44
1794:  MOVLW  1B
1796:  MOVWF  45
1798:  CALL   08CA
179C:  MOVLW  92
179E:  MOVWF  FF6
17A0:  MOVLW  05
17A2:  MOVWF  FF7
17A4:  MOVLW  05
17A6:  MOVWF  5E
17A8:  CALL   0882
17AC:  MOVFF  41,44
17B0:  MOVLW  1B
17B2:  MOVWF  45
17B4:  CALL   08CA
17B8:  MOVLW  99
17BA:  MOVWF  FF6
17BC:  MOVLW  05
17BE:  MOVWF  FF7
17C0:  MOVLW  05
17C2:  MOVWF  5E
17C4:  CALL   0882
17C8:  MOVFF  42,44
17CC:  MOVLW  1B
17CE:  MOVWF  45
17D0:  CALL   08CA
17D4:  MOVLW  A0
17D6:  MOVWF  FF6
17D8:  MOVLW  05
17DA:  MOVWF  FF7
17DC:  MOVLW  0C
17DE:  MOVWF  5E
17E0:  CALL   0882
....................             //  printf("\r\nID=%X", out_data[0]); 
....................             for (i=0;i<tx_len;i++) { 
17E4:  CLRF   38
17E6:  MOVF   36,W
17E8:  SUBWF  38,W
17EA:  BC    1826
....................                printf("\r\n%X ",out_data[i]); 
17EC:  CLRF   03
17EE:  MOVF   38,W
17F0:  ADDLW  29
17F2:  MOVWF  FE9
17F4:  MOVLW  00
17F6:  ADDWFC 03,W
17F8:  MOVWF  FEA
17FA:  MOVFF  FEF,41
17FE:  MOVLW  0D
1800:  BTFSS  F9E.4
1802:  BRA    1800
1804:  MOVWF  FAD
1806:  MOVLW  0A
1808:  BTFSS  F9E.4
180A:  BRA    1808
180C:  MOVWF  FAD
180E:  MOVFF  41,5E
1812:  MOVLW  37
1814:  MOVWF  5F
1816:  CALL   0A26
181A:  MOVLW  20
181C:  BTFSS  F9E.4
181E:  BRA    181C
1820:  MOVWF  FAD
1822:  INCF   38,F
1824:  BRA    17E6
....................             } 
....................             printf("\r\n"); 
1826:  MOVLW  0D
1828:  BTFSS  F9E.4
182A:  BRA    1828
182C:  MOVWF  FAD
182E:  MOVLW  0A
1830:  BTFSS  F9E.4
1832:  BRA    1830
1834:  MOVWF  FAD
....................          } 
1836:  BRA    1844
....................          else { //fail, no transmit buffer was open 
....................             printf("\r\nFAIL on PUTD\r\n"); 
1838:  MOVLW  AE
183A:  MOVWF  FF6
183C:  MOVLW  05
183E:  MOVWF  FF7
1840:  CALL   05C0
1844:  MOVLB  F
....................          
....................          } 
....................          
....................       } 
....................       delay_ms(500); 
1846:  MOVLW  02
1848:  MOVWF  41
184A:  MOVLW  FA
184C:  MOVWF  5E
184E:  MOVLB  0
1850:  CALL   05E2
1854:  DECFSZ 41,F
1856:  BRA    185A
1858:  BRA    185E
185A:  MOVLB  F
185C:  BRA    184A
185E:  BRA    163A
....................       // end  
....................      } 
....................       delay_ms(500); 
1860:  MOVLW  02
1862:  MOVWF  41
1864:  MOVLW  FA
1866:  MOVWF  5E
1868:  CALL   05E2
186C:  DECFSZ 41,F
186E:  BRA    1864
1870:  BRA    1626
....................    } 
.................... } 
1872:  SLEEP 

Configuration Fuses:
   Word  1: C200   HS FCMEN IESO
   Word  2: 1E1E   PUT BROWNOUT BORV21 NOWDT WDT32768
   Word  3: 8600   PBADEN LPT1OSC MCLR
   Word  4: 0091   STVREN NOLVP BBSIZ2K NOXINST NODEBUG
   Word  5: C00F   NOPROTECT NOCPB NOCPD
   Word  6: E00F   NOWRT NOWRTC NOWRTB NOWRTD
   Word  7: 400F   NOEBTR NOEBTRB
